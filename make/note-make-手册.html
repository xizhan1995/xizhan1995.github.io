<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <title>make 手册笔记/翻译 | 个人笔记</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.11a37516.js"><link rel="modulepreload" href="/assets/note-make-手册.html.54dfff79.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/note-make-手册.html.0a69e5b7.js">
    <link rel="stylesheet" href="/assets/style.b5235dab.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">个人笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/xizhan1995/xizhan1995.github.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/xizhan1995/xizhan1995.github.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p class="sidebar-item sidebar-heading">make 手册笔记/翻译 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#目录" class="router-link-active router-link-exact-active sidebar-item" aria-label="目录"><!--[--><!--]--> 目录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_1-概览" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 概览"><!--[--><!--]--> 1. 概览 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#准备" class="router-link-active router-link-exact-active sidebar-item" aria-label="准备"><!--[--><!--]--> 准备 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_1-1-如何阅读本手册" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 如何阅读本手册"><!--[--><!--]--> 1.1 如何阅读本手册 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_1-2-问题和bug" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 问题和bug"><!--[--><!--]--> 1.2 问题和bug <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-makefile文件的介绍" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Makefile文件的介绍"><!--[--><!--]--> 2. Makefile文件的介绍 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-1-what-a-rule-looks-like" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 What a Rule Looks Like"><!--[--><!--]--> 2.1 What a Rule Looks Like <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-2-a-simple-makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 A Simple Makefile"><!--[--><!--]--> 2.2 A Simple Makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-3-how-make-processes-a-makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 How make Processes a Makefile"><!--[--><!--]--> 2.3 How make Processes a Makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-4-variables-make-makefiles-simpler" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 Variables Make Makefiles Simpler"><!--[--><!--]--> 2.4 Variables Make Makefiles Simpler <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-5-letting-make-deduce-the-recipes" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 Letting make Deduce the Recipes"><!--[--><!--]--> 2.5 Letting make Deduce the Recipes <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-6-另一种风格的-makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.6 另一种风格的 makefile"><!--[--><!--]--> 2.6 另一种风格的 makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-7-清理目录的规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.7 清理目录的规则"><!--[--><!--]--> 2.7 清理目录的规则 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-writing-makefiles" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 Writing Makefiles"><!--[--><!--]--> 3 Writing Makefiles <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-1-makefile-包含的元素" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 Makefile 包含的元素"><!--[--><!--]--> 3.1 Makefile 包含的元素 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-2-指定-makefile-文件路径" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 指定 makefile 文件路径"><!--[--><!--]--> 3.2 指定 makefile 文件路径 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-3-包含其它makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 包含其它makefile"><!--[--><!--]--> 3.3 包含其它makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-4-变量-makefiles" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 变量 MAKEFILES"><!--[--><!--]--> 3.4 变量 MAKEFILES <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-5-remade-过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 Remade 过程"><!--[--><!--]--> 3.5 Remade 过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-6-覆盖另一个makfile的部分内容" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.6 覆盖另一个makfile的部分内容"><!--[--><!--]--> 3.6 覆盖另一个makfile的部分内容 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-7-读取makefile-两阶段" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.7 读取makefile：两阶段"><!--[--><!--]--> 3.7 读取makefile：两阶段 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-8-解析makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.8 解析Makefile"><!--[--><!--]--> 3.8 解析Makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-9-secondary-expansion-待续" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.9 Secondary Expansion  待续"><!--[--><!--]--> 3.9 Secondary Expansion  待续 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-书写规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 书写规则"><!--[--><!--]--> 4. 书写规则 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-1-示例" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 示例"><!--[--><!--]--> 4.1 示例 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-2-规则语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 规则语法"><!--[--><!--]--> 4.2 规则语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-3-prerequisite-的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 prerequisite 的分类"><!--[--><!--]--> 4.3 prerequisite 的分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-4-在文件名中使用通配符" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 在文件名中使用通配符"><!--[--><!--]--> 4.4 在文件名中使用通配符 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-prerequisite-的搜索路径-待续" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.5 prerequisite 的搜索路径  待续"><!--[--><!--]--> 4.5 prerequisite 的搜索路径  待续 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-6-phony-target" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.6 Phony target"><!--[--><!--]--> 4.6 Phony target <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-7-既没有-recipe-又没有-prerequisite-的规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.7 既没有 recipe 又没有 prerequisite 的规则"><!--[--><!--]--> 4.7 既没有 recipe 又没有 prerequisite 的规则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-8-用空的target文件记录事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.8 用空的target文件记录事件"><!--[--><!--]--> 4.8 用空的target文件记录事件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-9-有特殊意义的内置target-部分" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.9 有特殊意义的内置target : 部分"><!--[--><!--]--> 4.9 有特殊意义的内置target : 部分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-10-一个规则多个-target" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.10 一个规则多个 target"><!--[--><!--]--> 4.10 一个规则多个 target <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-11-一个-target-多个规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.11 一个 target 多个规则"><!--[--><!--]--> 4.11 一个 target 多个规则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-12-静态模板规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.12 静态模板规则"><!--[--><!--]--> 4.12 静态模板规则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-13-双冒号规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.13 双冒号规则"><!--[--><!--]--> 4.13 双冒号规则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-14-自动生成依赖" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.14 自动生成依赖"><!--[--><!--]--> 4.14 自动生成依赖 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-规则中的-recipe" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 规则中的 recipe"><!--[--><!--]--> 5 规则中的 recipe <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-1-语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 语法"><!--[--><!--]--> 5.1 语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-2-recipe-的回显" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 recipe 的回显"><!--[--><!--]--> 5.2 recipe 的回显 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-3-执行-recipe" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.3 执行 recipe"><!--[--><!--]--> 5.3 执行 recipe <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-4-并发执行" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.4 并发执行"><!--[--><!--]--> 5.4 并发执行 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-5-recipe-中的错误" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.5 recipe 中的错误"><!--[--><!--]--> 5.5 recipe 中的错误 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-6-终止-make" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.6 终止 make"><!--[--><!--]--> 5.6 终止 make <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-7-递归调用-make" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.7 递归调用 make"><!--[--><!--]--> 5.7 递归调用 make <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-8-定义容器-recipe" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.8 定义容器 recipe"><!--[--><!--]--> 5.8 定义容器 recipe <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-9-使用空-recipe" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.9 使用空 recipe"><!--[--><!--]--> 5.9 使用空 recipe <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_6-变量" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 变量"><!--[--><!--]--> 6 变量 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-how-to-run-make" class="router-link-active router-link-exact-active sidebar-item" aria-label="9. How to Run Make"><!--[--><!--]--> 9. How to Run Make <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-1-指定-makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.1 指定 makefile"><!--[--><!--]--> 9.1 指定 makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-2-指定-goal" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.2 指定 goal"><!--[--><!--]--> 9.2 指定 goal <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-3-instead-of-executing-recipes" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.3 Instead of Executing Recipes"><!--[--><!--]--> 9.3 Instead of Executing Recipes <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-4-跳过编译某些文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.4 跳过编译某些文件"><!--[--><!--]--> 9.4 跳过编译某些文件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-5-覆盖变量" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.5 覆盖变量"><!--[--><!--]--> 9.5 覆盖变量 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-6-测试编译过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.6 测试编译过程"><!--[--><!--]--> 9.6 测试编译过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-7-选项总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.7 选项总结"><!--[--><!--]--> 9.7 选项总结 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-using-implicit-rules" class="router-link-active router-link-exact-active sidebar-item" aria-label="10 Using Implicit Rules"><!--[--><!--]--> 10 Using Implicit Rules <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-1-using-implicit-rules" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.1 Using Implicit Rules"><!--[--><!--]--> 10.1 Using Implicit Rules <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-2-catalogue-of-built-in-rules" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.2 Catalogue of Built-In Rules"><!--[--><!--]--> 10.2 Catalogue of Built-In Rules <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-3-variables-used-by-implicit-rules" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.3 Variables Used by Implicit Rules"><!--[--><!--]--> 10.3 Variables Used by Implicit Rules <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-4-隐式规则的链式调用" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.4 隐式规则的链式调用"><!--[--><!--]--> 10.4 隐式规则的链式调用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-自定义和重新定义模式规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.5 自定义和重新定义模式规则"><!--[--><!--]--> 10.5 自定义和重新定义模式规则 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录" aria-hidden="true">#</a> 目录</h1><p><a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener noreferrer">https://www.gnu.org/software/make/manual/make.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#目录" class="router-link-active router-link-exact-active">目录</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_1-概览" class="router-link-active router-link-exact-active">1. 概览</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#准备" class="router-link-active router-link-exact-active">准备</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_1-1-如何阅读本手册" class="router-link-active router-link-exact-active">1.1 如何阅读本手册</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_1-2-问题和bug" class="router-link-active router-link-exact-active">1.2 问题和bug</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-makefile文件的介绍" class="router-link-active router-link-exact-active">2. Makefile文件的介绍</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-1-what-a-rule-looks-like" class="router-link-active router-link-exact-active">2.1 What a Rule Looks Like</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-2-a-simple-makefile" class="router-link-active router-link-exact-active">2.2 A Simple Makefile</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-3-how-make-processes-a-makefile" class="router-link-active router-link-exact-active">2.3 How make Processes a Makefile</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-4-variables-make-makefiles-simpler" class="router-link-active router-link-exact-active">2.4 Variables Make Makefiles Simpler</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-5-letting-make-deduce-the-recipes" class="router-link-active router-link-exact-active">2.5 Letting make Deduce the Recipes</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-6-另一种风格的-makefile" class="router-link-active router-link-exact-active">2.6 另一种风格的 makefile</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_2-7-清理目录的规则" class="router-link-active router-link-exact-active">2.7 清理目录的规则</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-writing-makefiles" class="router-link-active router-link-exact-active">3 Writing Makefiles</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-1-makefile-包含的元素" class="router-link-active router-link-exact-active">3.1 Makefile 包含的元素</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-1-1-续行" class="router-link-active router-link-exact-active">3.1.1 续行</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-2-指定-makefile-文件路径" class="router-link-active router-link-exact-active">3.2 指定 makefile 文件路径</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-3-包含其它makefile" class="router-link-active router-link-exact-active">3.3 包含其它makefile</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-4-变量-makefiles" class="router-link-active router-link-exact-active">3.4 变量 MAKEFILES</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-5-remade-过程" class="router-link-active router-link-exact-active">3.5 Remade 过程</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-6-覆盖另一个makfile的部分内容" class="router-link-active router-link-exact-active">3.6 覆盖另一个makfile的部分内容</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-7-读取makefile-两阶段" class="router-link-active router-link-exact-active">3.7 读取makefile：两阶段</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#条件指令立即展开" class="router-link-active router-link-exact-active">条件指令立即展开</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#规则定义" class="router-link-active router-link-exact-active">规则定义</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-8-解析makefile" class="router-link-active router-link-exact-active">3.8 解析Makefile</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_3-9-secondary-expansion-待续" class="router-link-active router-link-exact-active">3.9 Secondary Expansion 待续</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-书写规则" class="router-link-active router-link-exact-active">4. 书写规则</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-1-示例" class="router-link-active router-link-exact-active">4.1 示例</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-2-规则语法" class="router-link-active router-link-exact-active">4.2 规则语法</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-3-prerequisite-的分类" class="router-link-active router-link-exact-active">4.3 prerequisite 的分类</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-4-在文件名中使用通配符" class="router-link-active router-link-exact-active">4.4 在文件名中使用通配符</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-4-1-示例" class="router-link-active router-link-exact-active">4.4.1 示例</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-4-2-陷阱" class="router-link-active router-link-exact-active">4.4.2 陷阱</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-4-3-wildcard-函数" class="router-link-active router-link-exact-active">4.4.3 wildcard 函数</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-prerequisite-的搜索路径-待续" class="router-link-active router-link-exact-active">4.5 prerequisite 的搜索路径 待续</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-1-vpath-变量" class="router-link-active router-link-exact-active">4.5.1 VPATH 变量</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-2-vpath-指令" class="router-link-active router-link-exact-active">4.5.2 vpath 指令</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-3-目录搜索是如何执行的" class="router-link-active router-link-exact-active">4.5.3 目录搜索是如何执行的</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-4-书写可以适配-directory-search-的-recipe" class="router-link-active router-link-exact-active">4.5.4 书写可以适配 Directory Search 的 recipe</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-5-directory-search-和-implicit-rule" class="router-link-active router-link-exact-active">4.5.5 Directory Search 和 implicit rule</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-5-6-directory-search-和链接库-略" class="router-link-active router-link-exact-active">4.5.6 Directory Search 和链接库 略</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-6-phony-target" class="router-link-active router-link-exact-active">4.6 Phony target</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-7-既没有-recipe-又没有-prerequisite-的规则" class="router-link-active router-link-exact-active">4.7 既没有 recipe 又没有 prerequisite 的规则</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-8-用空的target文件记录事件" class="router-link-active router-link-exact-active">4.8 用空的target文件记录事件</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-9-有特殊意义的内置target-部分" class="router-link-active router-link-exact-active">4.9 有特殊意义的内置target : 部分</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-10-一个规则多个-target" class="router-link-active router-link-exact-active">4.10 一个规则多个 target</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-11-一个-target-多个规则" class="router-link-active router-link-exact-active">4.11 一个 target 多个规则</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-12-静态模板规则" class="router-link-active router-link-exact-active">4.12 静态模板规则</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-12-1-语法" class="router-link-active router-link-exact-active">4.12.1 语法</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-12-2-与隐式规则对比" class="router-link-active router-link-exact-active">4.12.2 与隐式规则对比</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-13-双冒号规则" class="router-link-active router-link-exact-active">4.13 双冒号规则</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_4-14-自动生成依赖" class="router-link-active router-link-exact-active">4.14 自动生成依赖</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-规则中的-recipe" class="router-link-active router-link-exact-active">5 规则中的 recipe</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-1-语法" class="router-link-active router-link-exact-active">5.1 语法</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-1-1-recipe-中的续行" class="router-link-active router-link-exact-active">5.1.1 recipe 中的续行</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-1-2-在-recipe-中使用变量" class="router-link-active router-link-exact-active">5.1.2 在 recipe 中使用变量</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-2-recipe-的回显" class="router-link-active router-link-exact-active">5.2 recipe 的回显</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-3-执行-recipe" class="router-link-active router-link-exact-active">5.3 执行 recipe</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-3-1-使用一个-shell" class="router-link-active router-link-exact-active">5.3.1 使用一个 shell</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-3-2-选择-shell" class="router-link-active router-link-exact-active">5.3.2 选择 shell</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-4-并发执行" class="router-link-active router-link-exact-active">5.4 并发执行</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-4-1-并发时的输出" class="router-link-active router-link-exact-active">5.4.1 并发时的输出</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-4-2-并发时的输入" class="router-link-active router-link-exact-active">5.4.2 并发时的输入</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-5-recipe-中的错误" class="router-link-active router-link-exact-active">5.5 recipe 中的错误</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-6-终止-make" class="router-link-active router-link-exact-active">5.6 终止 make</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-7-递归调用-make" class="router-link-active router-link-exact-active">5.7 递归调用 make</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-7-1-make变量的工作方式" class="router-link-active router-link-exact-active">5.7.1 MAKE变量的工作方式</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-7-2-向子-make-传递变量" class="router-link-active router-link-exact-active">5.7.2 向子 make 传递变量</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-7-3-向子-make-传递选项" class="router-link-active router-link-exact-active">5.7.3 向子 make 传递选项</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-7-4-print-directory-选项" class="router-link-active router-link-exact-active">5.7.4 --print-directory 选项</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-8-定义容器-recipe" class="router-link-active router-link-exact-active">5.8 定义容器 recipe</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_5-9-使用空-recipe" class="router-link-active router-link-exact-active">5.9 使用空 recipe</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_6-变量" class="router-link-active router-link-exact-active">6 变量</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-how-to-run-make" class="router-link-active router-link-exact-active">9. How to Run Make</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-1-指定-makefile" class="router-link-active router-link-exact-active">9.1 指定 makefile</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-2-指定-goal" class="router-link-active router-link-exact-active">9.2 指定 goal</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-3-instead-of-executing-recipes" class="router-link-active router-link-exact-active">9.3 Instead of Executing Recipes</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-4-跳过编译某些文件" class="router-link-active router-link-exact-active">9.4 跳过编译某些文件</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-5-覆盖变量" class="router-link-active router-link-exact-active">9.5 覆盖变量</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-6-测试编译过程" class="router-link-active router-link-exact-active">9.6 测试编译过程</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_9-7-选项总结" class="router-link-active router-link-exact-active">9.7 选项总结</a></li></ul></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-using-implicit-rules" class="router-link-active router-link-exact-active">10 Using Implicit Rules</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-1-using-implicit-rules" class="router-link-active router-link-exact-active">10.1 Using Implicit Rules</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-2-catalogue-of-built-in-rules" class="router-link-active router-link-exact-active">10.2 Catalogue of Built-In Rules</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-3-variables-used-by-implicit-rules" class="router-link-active router-link-exact-active">10.3 Variables Used by Implicit Rules</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-4-隐式规则的链式调用" class="router-link-active router-link-exact-active">10.4 隐式规则的链式调用</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-自定义和重新定义模式规则" class="router-link-active router-link-exact-active">10.5 自定义和重新定义模式规则</a><ul><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-1-introduction-to-pattern-rules" class="router-link-active router-link-exact-active">10.5.1 Introduction to Pattern Rules</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-2-pattern-rule-examples" class="router-link-active router-link-exact-active">10.5.2 Pattern Rule Examples</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-3-automatic-variables" class="router-link-active router-link-exact-active">10.5.3 Automatic Variables</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-4-how-patterns-match" class="router-link-active router-link-exact-active">10.5.4 How Patterns Match</a></li><li><a aria-current="page" href="/make/note-make-%E6%89%8B%E5%86%8C.html#_10-5-5-match-anything-pattern-rules" class="router-link-active router-link-exact-active">10.5.5 Match-Anything Pattern Rules</a></li></ul></li></ul></li></ul></nav><p>看标题，手册的前 10 章属于 Make 工具基础知识。 第 16 章则是一些最佳实践。</p><h1 id="_1-概览" tabindex="-1"><a class="header-anchor" href="#_1-概览" aria-hidden="true">#</a> 1. 概览</h1><p>Overview</p><p>make 工具可以自动确定一个大型程序中的哪些部分需要更新,并执行命令重新编译这些部分. 本手册描述make工具的用法. make 由 Richard Stallman(理查德·斯托曼) 和 Roland McGrath(罗兰·麦格拉思) 开发, 自 3.76 之后, 由 Paul D. Smith 开发.</p><p>GNU make 工具兼容 POSIX.2 中的 6.2 节的要求.</p><p>手册中使用 C 程序为例展示 make 的用法, 因为C程最常见，但make不仅限于处理C程序, 任何可以使用shell命令编译的程序都可以。实际上 make 不仅限于编程语言。 任何符合依赖+更新+shell命令的任务都可以。 ps: 但c却是最契合的,因为 make 就是为这一目标为动机开发的.</p><h2 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h2><p>为了使用 make, 你需要编写一个 makefile 文件, 它描述了你的程序的各个文件之间的 关系以及如何重新编译他们需要执行的命令.</p><p>如果你为自己的项目编写了合适的 makefile, 则每当你修改了某个源代码之后,只需要执行 一条简单的命令<code>make</code>就能完成所有必要的更新. make 命令使用 makefile 中的信息以及 每个文件的最新修改时间决定那些文件需要更新, 更新文件要执行的命令同样在makefile中 提供.</p><p>还可以通过命令行控制make更新哪些文件.</p><h2 id="_1-1-如何阅读本手册" tabindex="-1"><a class="header-anchor" href="#_1-1-如何阅读本手册" aria-hidden="true">#</a> 1.1 如何阅读本手册</h2><p>如果是你新手或者只要了解make的大概用法，那么只需要阅读每章的前几个小节即可，因为每章 中的前面的小节是简要介绍，而后面的章节则是深入讲解。第二章是例外，此章的整个章节都是 介绍性的内容。 如果你是对其他make工具熟悉，可以阅读Features of GNU make和 Incompatibilities and Missing Features这两个章节。 如果快速看一遍概要，去看　Options Summary,　Quick Reference和 Special Targets.</p><h2 id="_1-2-问题和bug" tabindex="-1"><a class="header-anchor" href="#_1-2-问题和bug" aria-hidden="true">#</a> 1.2 问题和bug</h2><p>这里介绍如何提出bug。</p><ul><li>不保证一定解决，但一般会修复</li><li>仔细确认确实是bug</li><li>提交bug要提供可以复现问题的最小makile文件，完整的错误输出，给出你的期望结果</li><li>带上make工具的版本号</li></ul><h1 id="_2-makefile文件的介绍" tabindex="-1"><a class="header-anchor" href="#_2-makefile文件的介绍" aria-hidden="true">#</a> 2. Makefile文件的介绍</h1><p>你需要用被称为makfile的文件告诉make工具做什么。一般是告诉make如何编译和链接程序。</p><p>本手册使用一个示例程序作为书中例子的操作对象，这个程序是一个文本编辑器，它由8个源代码 文件和3个头文件构成。</p><p>Q. 这个程序的源文在哪里？</p><blockquote><p>When make recompiles the editor, each changed C source file must be recompiled. If a header file has changed, each C source file that includes the header file must be recompiled to be safe. Each compilation produces an object file corresponding to the source file. Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable editor.</p></blockquote><p>本章概要：</p><ul><li>Rule Introduction What a rule looks like.</li><li>Simple Makefile A simple makefile.</li><li>How Make Works How make processes this makefile.</li><li>Variables Simplify Variables make makefiles simpler.</li><li>make Deduces Letting make deduce the recipes.</li><li>Combine By Prerequisite Another style of makefile.</li><li>Cleanup Rules for cleaning the directory.</li></ul><h2 id="_2-1-what-a-rule-looks-like" tabindex="-1"><a class="header-anchor" href="#_2-1-what-a-rule-looks-like" aria-hidden="true">#</a> 2.1 What a Rule Looks Like</h2><p>makefile 的基本组成元素是 rule。 一个 rule 由 targte、prerequisite、recipe 三部分构成，target 是必须的，prerequisite 和 recipe 可以省略其一，但不许同时省略。 rule 说明何时以及如何更新target。 target 分为两种，普通 target 对应生成的文件，phony target（伪目标）指定要执行的动作的名称。 recipe 中的每一行都得以 tab 字符开头。也可以改为其它字符开头，设置 .RECIPEPREFIX 变量即可。</p><p>规则的构成形式如下：</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>target … : prerequisites …
        recipe
        …
        …
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>A <code>target</code> is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).</p><p>A <code>prerequisite</code> is a file that is used as input to create the target. A target often depends on several files.</p><p>A <code>recipe</code> is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see Special Variables).</p><p>makefile 可以包含规则之外的内容，但基础的makefile文件只需要包含规则就够了。 实际的makefile比这里的示例要复杂一些，但原理都是一样的。</p><h2 id="_2-2-a-simple-makefile" tabindex="-1"><a class="header-anchor" href="#_2-2-a-simple-makefile" aria-hidden="true">#</a> 2.2 A Simple Makefile</h2><p>这里是一个简单的makefile文件，用于编译本本手册使用的示例程序。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">edit</span> <span class="token punctuation">:</span> main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

<span class="token symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h
        cc -c main.c
<span class="token symbol">kbd.o</span> <span class="token punctuation">:</span> kbd.c defs.h command.h
        cc -c kbd.c
<span class="token symbol">command.o</span> <span class="token punctuation">:</span> command.c defs.h command.h
        cc -c command.c
<span class="token symbol">display.o</span> <span class="token punctuation">:</span> display.c defs.h buffer.h
        cc -c display.c
<span class="token symbol">insert.o</span> <span class="token punctuation">:</span> insert.c defs.h buffer.h
        cc -c insert.c
<span class="token symbol">search.o</span> <span class="token punctuation">:</span> search.c defs.h buffer.h
        cc -c search.c
<span class="token symbol">files.o</span> <span class="token punctuation">:</span> files.c defs.h buffer.h command.h
        cc -c files.c
<span class="token symbol">utils.o</span> <span class="token punctuation">:</span> utils.c defs.h
        cc -c utils.c
<span class="token symbol">clean</span> <span class="token punctuation">:</span>
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>在行末用 \ 可以续行。</p><p>使用如下命令编译项目：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>使用如下命令清理目录：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span> clean
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first. In this example, edit depends on each of the eight object files; the object file main.o depends on the source file main.c and on the header file defs.h.</p><p>recipe 中的每行命令都必须以tab开头。</p><p>这里的目标<code>clean</code>不是文件，而仅是某个动作的名称。一般不运行此目标，所以它没有作为任何 目标的前置条件，所以仅当明确指定它的时候，clean目标才会被执行；同时它没有任何前置条件， 所以这条规则的唯一目的就是运行指定的recipe。 不指向文件，而仅作是一个动作的target叫做 Phony Target。</p><h2 id="_2-3-how-make-processes-a-makefile" tabindex="-1"><a class="header-anchor" href="#_2-3-how-make-processes-a-makefile" aria-hidden="true">#</a> 2.3 How make Processes a Makefile</h2><p>第一条规则的target叫做 default goal。 特殊变量 .DEFAULT_GOAL 可以指定自定义的 default goal。</p><p>直接输入make，不带任何参数，它执行的就是 default goal。</p><p>下面一段，说明了执行 make 命令后发生的事情。</p><p>Thus, when you give the command:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>make reads the makefile in the current directory and begins by processing the first rule. In the example, this rule is for relinking edit; but before make can fully process this rule, it must process the rules for the files that edit depends on, which in this case are the object files. Each of these files is processed according to its own rule. These rules say to update each ‘.o’ file by compiling its source file. The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist.</p><p>The other rules are processed because their targets appear as prerequisites of the goal. If some other rule is not depended on by the goal (or anything it depends on, etc.), that rule is not processed, unless you tell make to do so (with a command such as make clean).</p><p>Before recompiling an object file, make considers updating its prerequisites, the source file and header files. This makefile does not specify anything to be done for them—the ‘.c’ and ‘.h’ files are not the targets of any rules—so make does nothing for these files. But make would update automatically generated C programs, such as those made by Bison or Yacc, by their own rules at this time.</p><p>After recompiling whichever object files need it, make decides whether to relink edit. This must be done if the file edit does not exist, or if any of the object files are newer than it. If an object file was just recompiled, it is now newer than edit, so edit is relinked.</p><p>Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit.</p><h2 id="_2-4-variables-make-makefiles-simpler" tabindex="-1"><a class="header-anchor" href="#_2-4-variables-make-makefiles-simpler" aria-hidden="true">#</a> 2.4 Variables Make Makefiles Simpler</h2><p>说上面这个简单的 Makefile 要手动列出所有 .o 文件，列出了两次。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">edit</span> <span class="token punctuation">:</span> main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这容易出错，比如当新增一个 .o 文件的时候，我们可能只更新了其中一个地方，而忘记更新另一个地方。 变量帮助解降低这方面的风险。变量可以让一个字符串在一处定义然后在别处多次引用。</p><p>最佳实践：把所有的目标文件名放在一个叫做 objects 的变量中。 然后凡是用到目标文件列表的地方都用 $(objects) 代替。</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="_2-5-letting-make-deduce-the-recipes" tabindex="-1"><a class="header-anchor" href="#_2-5-letting-make-deduce-the-recipes" aria-hidden="true">#</a> 2.5 Letting make Deduce the Recipes</h2><p>没有必要把所有编译单个c文件的规则都敲出来，因为make会自动判断出编译 .o 文件的方式，这 归功于隐式规则(implicit rule)。</p><p>这里用到的隐式规则会自动把 .c 文件添加为 .o 文件的 prerequisite，所以不必再显式列出 .o 文件依赖的 .c 文件了。</p><p>综合变量和隐式规则，示例中的makefile可以进一步精简为下面这样。</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这才是我们实际使用的makefile的样子。</p><p>隐式规则十分方便，你会经常用到他们。所以要掌握好隐式规则。</p><h2 id="_2-6-另一种风格的-makefile" tabindex="-1"><a class="header-anchor" href="#_2-6-另一种风格的-makefile" aria-hidden="true">#</a> 2.6 另一种风格的 makefile</h2><p>前面的示例中，按 .o 文件组织规则。还有一种风格，根据被依赖的 .h 文件分组组织规则，如下：</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>哪种风格好，看个人喜好。这种风格更紧凑，但第一种风格把目标的所有依赖都列在一处，所以更清晰。</p><h2 id="_2-7-清理目录的规则" tabindex="-1"><a class="header-anchor" href="#_2-7-清理目录的规则" aria-hidden="true">#</a> 2.7 清理目录的规则</h2><p>除了编译程序，有时候还希望用规则写点别的任务，比如清理目录。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">clean</span><span class="token punctuation">:</span>
        rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为了更准确地表达我们的意图，避免意外情况，稍微改写一下</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token symbol">clean</span><span class="token punctuation">:</span>
        -rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当真的存在名为 clean 的文件时，make 会疑惑，所以用<code>.PHONY: clean</code>告诉make这是个伪目标。 rm命令签前面的 - 表示忽略命令的错误。</p><h1 id="_3-writing-makefiles" tabindex="-1"><a class="header-anchor" href="#_3-writing-makefiles" aria-hidden="true">#</a> 3 Writing Makefiles</h1><blockquote><p>The information that tells make how to recompile a system comes from reading a data base called the makefile.</p></blockquote><h2 id="_3-1-makefile-包含的元素" tabindex="-1"><a class="header-anchor" href="#_3-1-makefile-包含的元素" aria-hidden="true">#</a> 3.1 Makefile 包含的元素</h2><p>What Makefiles Contain</p><p>makefile 包含五种顶级语法元素。</p><ul><li>Explicit rules</li><li>Implicit rules</li><li>Variable definitions</li><li>Directives</li><li>Comments</li></ul><p>续行符不受注释的影响。 变量引用和函数引用中的井号不做注释解释。 recipe 中的注释会原样传递给shell。 define 中的注释，会带到变量定义中。</p><ul><li><p>An explicit rule says when and how to remake one or more files, called the rule’s targets. It lists the other files that the targets depend on, called the prerequisites of the target, and may also give a recipe to use to create or update the targets. See <a href="https://www.gnu.org/software/make/manual/make.html#Rules" title="第四章" target="_blank" rel="noopener noreferrer">Writing Rules<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p></li><li><p>An implicit rule says when and how to remake a class of files based on their names. It describes how a target may depend on a file with a name similar to the target and gives a recipe to create or update such a target. See <a href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" title="第十章" target="_blank" rel="noopener noreferrer">Using Implicit Rules<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p></li><li><p>A variable definition is a line that specifies a text string value for a variable that can be substituted into the text later. The simple makefile example shows a variable definition for objects as a list of all object files (see Variables Make Makefiles Simpler).</p></li><li><p>A directive is an instruction for make to do something special while reading the makefile. These include:</p><ul><li>Reading another makefile (see Including Other Makefiles).</li><li>Deciding (based on the values of variables) whether to use or ignore a part of the makefile (see Conditional Parts of Makefiles).</li><li>Defining a variable from a verbatim string containing multiple lines (see Defining Multi-Line Variables).</li></ul></li><li><p>makefile 中用井号（<code>#</code>）做单行注释字符。井号直到行末都是注释，如果行末有未转义的反斜杠续行，则注释会蔓延到多行。 仅含注释的行（开头可以有空白字符）等效于空白，会被忽略。要将井号作为普通字符插入，可以用反斜杠转义<code>\#</code>。 注释可以出现在 makefile 的任何一行，尽管某些地方会对注释做特殊处理。</p><p>函数调用和变量引用中的井号不算注释。</p><p>recipe 中的注释会原样传递给 shell，到了shell中是否是注释则要看shell的语法规则。</p><p>define 指令中，注释也会包含在变量值中，当变量展开的时候，注释会一并带过去，然后根据变量展开 的位置解释为makefile的注释或者recipe文本。</p></li></ul><h3 id="_3-1-1-续行" tabindex="-1"><a class="header-anchor" href="#_3-1-1-续行" aria-hidden="true">#</a> 3.1.1 续行</h3><p>Splitting Long Lines</p><p>Makefile 中，换行符标志语句的结束。不限制行的长度。</p><p>一行太长，不便于阅读，所以提供了续行的语法。 为了区分，定义物理行和逻辑行。</p><p><strong>斜杠+换行</strong>构成续行。在 recipe 中和 recipe 之外的续行处理略有不同。</p><p>recipe 之外的地方的续行（斜杠+换行）会替换为单个空格。包括</p><ul><li>续行前后的空白</li><li>连续的续行</li></ul><p>例如：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>foo=hello       \
                world
bar=hello\
world
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>等价于</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>foo=hello world
bar=hello world
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>想要去掉这行造成的空格，可以使用这样一个变通的法子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var := one$\
       word
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>等价于 <code>var := one$ world</code> 而其中 <code>$ </code> 会被解释为变量替换，变量的名字是单个空个字符， 这个变量未定义，所以展开为空字符：<code>var :=oneworld</code>。</p><p>recipe 中的续行，含义有些不同。参见 <a href="https://www.gnu.org/software/make/manual/make.html#Splitting-Recipe-Lines" target="_blank" rel="noopener noreferrer">5.1.1 Splitting Recipe Lines<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><h2 id="_3-2-指定-makefile-文件路径" tabindex="-1"><a class="header-anchor" href="#_3-2-指定-makefile-文件路径" aria-hidden="true">#</a> 3.2 指定 makefile 文件路径</h2><p>首先，可以使用 -f --file 指定makefile的名字。 其次，如果没有使用 -f 选项，GNU make 会依次尝试 GNUmakefile, Makefile, makefles，</p><p>可以多次指定 -f 选项，make 会把这些文件的内容按顺序拼接起来。 一旦指定 -f 选项，make 就不会尝试默认文件名。</p><p>如果这些文件名都不存在，make 不会使用任何 makefile，此时必须在命令行中指定要构建的目标， make 会尝试用内置规则构建指定的目标。</p><p>PS：如果找不到构建相关目标的规则，会报错:<code>make: *** No rule to make target &#39;foo&#39;. Stop.</code>； PS：更多细节，待我挖掘。</p><h2 id="_3-3-包含其它makefile" tabindex="-1"><a class="header-anchor" href="#_3-3-包含其它makefile" aria-hidden="true">#</a> 3.3 包含其它makefile</h2><p>include 指令用于包含其他makeilfe文件。make 处理到include指令的时候会暂停处理当前 makefile，转而读取include指定的makefile，待处理完成后，从include指令处继续处理当前 makefile。</p><p>包含指令样子如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>include filenames...
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>空：filesnames 可以是空，不会报错，make 不读任何文件。</li><li>空格：inlcude 前面可以有空格，会被忽略。但开头第一个字符不可以是tab（.RECIPEPREFIX字符）。</li></ul><p>include 和其后的文件名之间必须有一个空格，多个文件名之间也必须有一个空格。一个空格就够， 但多了也没问题。</p><ul><li>注释：include指令行的末尾可以有 # 引导的注释</li><li>变量和函数：变量和函数引用会展开为对应的文件名后再include。</li></ul><p>假设有三个 .mk 文件：a.mk, b.mk, and c.mk, and $(bar) 扩展为 bish bash，则</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">include</span> foo *.mk <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>等价于</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">include</span> foo a.mk b.mk c.mk bish bash
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>使用 include 指定的场景。</p><ul><li>多个程序用在不同目录中用不同的makefile构建，且这些makefile有公共的变量设置或模式规则设置。 Q. 是每个makefile都包含一次公共makefile，还是把公共配置放到主makefile中然后包含所有子makefile？</li><li>当需要从源文件自动计算某些依赖关系时。比如 C 程序的头文件包含那个例子。</li></ul><p>如果在 include 后面指定的文件名不是绝对路径且在当前目录下不存在，make 会依次搜索如下目录</p><ul><li>选项 -I --include-dir 指定的目录</li><li>prefix/include (通常是 /usr/local/include) /usr/gnu/include, /usr/local/include, /usr/include，如果这些目录存在的话</li></ul><p>如果被包含的文件不存在，会先给出警告，然后继续处理当前makefile，等读取完成，make 尝试 更新所有过时和不存在的makefile，然后如果还有被包含的makefile无法找到，则报错退出。 参考<a href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles" title="3.5 How Makefiles Are Remade" target="_blank" rel="noopener noreferrer">How Makefiles Are Remade<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><p>如果希望被包含的 makefile 缺失或无法 remade 时不报错退出，只要用 <code>-include</code> 代替 <code>include</code> 指令即可。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">-include</span> filenames…
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>要保持与其它 make 工具兼容，使用 sininclude 替代 -include。</p><p>Q. - 和 include 中间可以有空格吗？ Ans：在 GNU Make 4.3 实测，不可以。会报错<code>Makefile:2: *** missing separator. Stop.</code> 另外，-include，当文件不存在时，不仅不报错，连警告都不会有。</p><h2 id="_3-4-变量-makefiles" tabindex="-1"><a class="header-anchor" href="#_3-4-变量-makefiles" aria-hidden="true">#</a> 3.4 变量 MAKEFILES</h2><p>The Variable MAKEFILES</p><p>如果设置了环境变量 MAKEFILES ，make 先读取此变量中列出的 makefile 文件名（用空格分隔），在主makefile之前。 对此变量中文件的处理类似 -include 指令，会搜索相关路径、文件缺失也不会报错。 另外，make 不会从 MAKEFILES 指定的 makefile 以及它们包含的 makefile 计算 default goal。 ps：但是，可以在 MAKEFILES 指定的makefile中设置特殊变量 .DEFAULT_GOAL，设置 default goal。</p><p>Q. MAKEFILES 中的文件找不到，会尝试 remake 吗？</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">cat</span> Makefile
<span class="token variable"><span class="token variable">$(</span>info reading Makefile<span class="token variable">)</span></span>
hello:
        @echo hello, world
<span class="token variable"><span class="token variable">$(</span>info end reading Makefile<span class="token variable">)</span></span>

$ <span class="token function">cat</span> <span class="token function">make</span>
<span class="token variable"><span class="token variable">$(</span>info reading <span class="token function">make</span><span class="token variable">)</span></span>
<span class="token variable"><span class="token variable">$(</span>info end reading <span class="token function">make</span><span class="token variable">)</span></span>
$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">MAKEFILES</span><span class="token operator">=</span>make

<span class="token comment"># 可以看到，make 先于 Makefile 读取</span>
$ <span class="token function">make</span>
reading <span class="token function">make</span>
end reading <span class="token function">make</span>
reading Makefile
end reading Makefile
hello, world
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>MAKEFILES 一般用在递归调用 make 时。很少在调用顶级 makefile 的时候配置它，因为把外部makefile 和当前makefile混杂在一起不好。但是，未指定特定的 makefile 而运行 make 命令的时候，可以 通过设置此变量改良内置隐式规则。</p><p>有些用户习惯在登录shell的启动脚本中配置此变量，这非常不好，因为写出来的makefile放在 别人运行时就会报错，使用 include 指令明确被包含的makefile是更好的选择。</p><h2 id="_3-5-remade-过程" tabindex="-1"><a class="header-anchor" href="#_3-5-remade-过程" aria-hidden="true">#</a> 3.5 Remade 过程</h2><p>How Makefiles Are Remade</p><p>有时可以从其它途径生成makefile，也希望make能用上最新的makefile。</p><p>为了应对此需求，make 提供remake机制。当所有makefile都读取完毕后，make 尝试分别以每个 makefile 文件名为目标，查找可以生成/更新它们的规则，如果有就应用，当所有 makefile 都 检查一遍后，如果确实存在某个makefile被更新了，make 会从干净的状态重新读取makefile， 重新读取后仍旧会进行这些检查，直到某次检查后所有makefile都没有变化。每次重启，make 会更新特殊变量 MAKE_RESTARTS 的值。</p><p>ps：显然，入口 makefile 也在这个 remake 过程的检查范围之内。</p><p>如果某个 makefile 可以由某条 double-colon rule 生成，而此 double-colon rule 只有 recipe 没有 prerequisite，这样的规则每次都会执行，那 make 每次检查都会重新生成 makefile， 导致死循环，为了避开这一点，在 remake 的时候，如果某个 makefile 是某条只有 recebe 没有 prerequisite 的规则的 target，make 不会 remake这个文件。</p><blockquote><p>So, to avoid this, make will not attempt to remake makefiles which are specified as targets of a double-colon rule with a recipe but no prerequisites.</p></blockquote><p>如果没有指定 makefile （-f 选项），make 会依次尝试默认文件名（GNUMakefile，makefile、 Makefile），如果这些默认文件名都不存在，make 会尝试使用 make rule 生成它们，如果仍旧 不能生成，那就没有，没有也不算报错，因为 makefile 并不是必须的。</p><p>Q. 并没有说 -f 指定的文件名不存在时是否会尝试构建。 Ans: 会，且无对应规则或规则无法生成时，会报错退出，相比之下，缺省makefile文件如果 最终缺失，却不会报错。 如下，报错 No rule to make target &#39;Makefile2&#39;，说明 make 确实尝试生成它了。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span> -f Makefile2 hello
make: Makefile2: No such <span class="token function">file</span> or directory
make: *** No rule to <span class="token function">make</span> target <span class="token string">&#39;Makefile2&#39;</span><span class="token builtin class-name">.</span>  Stop.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>-t 选项不会影响 makefile 的remake过程，因为若某个 makefile 过时，-t 选项的输出就会不 准确，这是不行的。同理，-q 和 -n 选项也不会影响 makefile 的 remake 过程。</p><p>如果确实要求 -t、-q、-n选项连带着 makefile 的 remake 过程也抑制，把 makefile 名作为 目标明确指定在命令行上就行了。</p><blockquote><p>However, on occasion you might actually wish to prevent updating of even the makefiles. You can do this by specifying the makefiles as goals in the command line as well as specifying them as makefiles. When the makefile name is specified explicitly as a goal, the options ‘-t’ and so on do apply to them.</p></blockquote><p>还举了一个例子。</p><blockquote><p>Thus, ‘make -f mfile -n mfile foo’ would read the makefile mfile, print the recipe needed to update it without actually running it, and then print the recipe needed to update foo without running that. The recipe for foo will be the one specified by the existing contents of mfile.</p></blockquote><h2 id="_3-6-覆盖另一个makfile的部分内容" tabindex="-1"><a class="header-anchor" href="#_3-6-覆盖另一个makfile的部分内容" aria-hidden="true">#</a> 3.6 覆盖另一个makfile的部分内容</h2><p>Overriding Part of Another Makefile</p><p>这里的场景是：大部分内容一样，但部分规则需要重写。</p><p>没有专门的语法实现这一点，只是通过某些技巧实现这一目的。</p><ul><li>ps：include 指令无法实现这一目的，因为同一个 target 有多个 recipe 会报错。</li></ul><p>假设已有文件 Makefile，其包含构造目标 foo 的规则以及其它规则，要新编写文件 GNUMakefile， 它大部分与 Makefile 规则相同，只是需要重写 foo 规则，则按如下方式编写 GNUMakefile</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment">#File: GNUMake</span>
<span class="token symbol">foo</span><span class="token punctuation">:</span>
        frobnicate &gt; foo

<span class="token symbol">%</span><span class="token punctuation">:</span> force
        <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -f Makefile <span class="token variable">$@</span>
<span class="token symbol">force</span><span class="token punctuation">:</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol><li>用 % 规则兜底，转发给 Makefile</li><li>用 force 作为 % 的 prerequisite，确保 % 必定执行（确保其不会因为存在同名文件而得不到执行）</li><li>为 force 提供了空的 recipe，避免 force 本身匹配到 % 规则，导致死循环。</li></ol><h2 id="_3-7-读取makefile-两阶段" tabindex="-1"><a class="header-anchor" href="#_3-7-读取makefile-两阶段" aria-hidden="true">#</a> 3.7 读取makefile：两阶段</h2><p>How make Reads a Makefile</p><p>make 分成两个阶段完成其工作。在第一个阶段，make 读取所有 makefile、被包含的makefile等， 初始化所有变量定义、变量值、隐式规则、显式规则，并构建所有 target 和 prerequisite 的 依赖图。第二阶段，make 根据上述数据检查、确认需要更新的 target 并运行必要的 recipe 完成更新。</p><p>ps：read-in phase, target-update phase。</p><p>make 的两阶段工作直接影响变量展开和函数展开的时机，理解这些就可以理解一些易混淆的结构。</p><p>展开分为两种，在第一阶段发生的叫立即展开（immediate）：解析makefile 的时候执行展开； 不是理解展开的叫延迟展开（deferred），它们在使用的时候才展开：要么在立即展开上下文中被 引用的时候，要么在第二阶段被引用的时候。</p><blockquote><p>We say that expansion is immediate if it happens during the first phase: make will expand that part of the construct as the makefile is parsed. We say that expansion is deferred if it is not immediate. Expansion of a deferred construct part is delayed until the expansion is used: either when it is referenced in an immediate context, or when it is needed during the second phase.</p></blockquote><p>PS：教程列出了一些由此带来的常见的易混淆结构，并给出了解释。</p><p>这里的某些语句涉及到陌生的语法，可以熟悉之后再来回顾。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>immediate <span class="token operator">=</span> deferred
immediate <span class="token operator">?=</span> deferred
immediate <span class="token operator">:=</span> immediate
<span class="token symbol">immediate</span> <span class="token operator">::=</span> immediate
immediate <span class="token operator">+=</span> deferred or immediate
immediate <span class="token operator">!=</span> immediate
<span class="token keyword">define</span> immediate
  deferred
<span class="token keyword">endef</span>

<span class="token keyword">define</span> immediate <span class="token operator">=</span>
  deferred
<span class="token keyword">endef</span>

<span class="token keyword">define</span> immediate <span class="token operator">?=</span>
  deferred
<span class="token keyword">endef</span>

<span class="token keyword">define</span> immediate <span class="token operator">:=</span>
  immediate
<span class="token keyword">endef</span>

<span class="token symbol">define immediate</span> <span class="token operator">::=</span>
  immediate
<span class="token keyword">endef</span>

<span class="token keyword">define</span> immediate <span class="token operator">+=</span>
  deferred or immediate
<span class="token keyword">endef</span>

<span class="token keyword">define</span> immediate <span class="token operator">!=</span>
  immediate
<span class="token keyword">endef</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p><code>+=</code> 操作符右侧会立即展开如果被引用的变量本身是简单变量（:= 或 ::=定义的），否则延迟展开。 <code>!=</code> 操作符（shell assignment operator），右侧会立即展开，传递给shell，并把结果存入左侧 变量中，同时左侧的变量是简单变量。</p><h3 id="条件指令立即展开" tabindex="-1"><a class="header-anchor" href="#条件指令立即展开" aria-hidden="true">#</a> 条件指令立即展开</h3><p>条件指令在解析时立即展开。这意味着条件指令中无法使用自动变量，自动变量在 recipe 实际 执行的时候才会设置好。如果需要，就把条件处理逻辑放到 recipe中，同时用 shell 的 if 语句代替。</p><h3 id="规则定义" tabindex="-1"><a class="header-anchor" href="#规则定义" aria-hidden="true">#</a> 规则定义</h3><p>规则定义，不论形式，其展开时机如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">immediate</span> <span class="token punctuation">:</span> immediate <span class="token punctuation">;</span> deferred
        deferred
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也就是说，rule 中的 target 和 prerequisite 都是立即展开，而 recipe 总是延迟展开。 explicit rules, pattern rules, suffix rules, static pattern rules, 和 simple prerequisite definitions 都是如此。</p><h2 id="_3-8-解析makefile" tabindex="-1"><a class="header-anchor" href="#_3-8-解析makefile" aria-hidden="true">#</a> 3.8 解析Makefile</h2><p>How Makefiles Are Parsed</p><p>make 逐行解析 makefile，步骤如下：</p><ol><li>读取一个逻辑行</li><li>删除其中的注释</li><li>如果是 RECIPEPREFIX 开头且在 rule context 中，把当前行加入当前 recipe 中；然后读取下一个逻辑行</li><li>检查其中的立即展开元素并展开</li><li>搜索行中的 : 和 = 分隔符，区分是规则定义还是变量赋值（原文是 macro assignment，我猜就是指变量定义）</li><li>处理下一行</li></ol><p>基于这些规则，一个显而易见的推论是，可通过变量定义单行规则：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>myrule <span class="token operator">=</span> target <span class="token punctuation">:</span> <span class="token punctuation">;</span> echo built

<span class="token variable">$</span><span class="token punctuation">(</span>myrule<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但是下面这一段就不行了，因为make不会对展开结果拆行处理。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">define</span> myrule
<span class="token symbol">target</span><span class="token punctuation">:</span>
        echo built
<span class="token keyword">endef</span>

<span class="token variable">$</span><span class="token punctuation">(</span>myrule<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>实际等效于 <code>target: ; echo built</code>，其中的换行符仍旧保留，但效果和空白字符相同。</p><p>要让多行变量值展开为规则，需要用 eval 函数。</p><h2 id="_3-9-secondary-expansion-待续" tabindex="-1"><a class="header-anchor" href="#_3-9-secondary-expansion-待续" aria-hidden="true">#</a> 3.9 Secondary Expansion 待续</h2><p>make 有两个工作阶段，read-in phase 和 target-update phase。 GNU Make 还支持二次展开（secondary expansion），二次展开是指，在 read-in phase 之后，对某些或所有 target 对应的 prerequisite 部分进行一次展开。要启用这个特性， 得借助特殊 target .SECONDEXPANSION。</p><blockquote><p>In order for this second expansion to occur, the special target .SECONDEXPANSION must be defined before the first prerequisite list that makes use of this feature.</p></blockquote><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.SECONDEXPANSION</span><span class="token punctuation">:</span>
ONEVAR <span class="token operator">=</span> onefile
TWOVAR <span class="token operator">=</span> twofile
<span class="token symbol">myfile</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>ONEVAR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TWOVAR<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>一些使用场景，一些“边界”情景。</p><p>自动变量在 prerequisite 中是无法使用的，但借助二次展开就可以用上，只不过需要用 $ 代替 $。 ps：据文档所说，这正是二次展开的威力所在。但我目前不需要学这么深入，知道有这回事就行。</p><h1 id="_4-书写规则" tabindex="-1"><a class="header-anchor" href="#_4-书写规则" aria-hidden="true">#</a> 4. 书写规则</h1><p>Writing Rules</p><p>规则的 target、prerequisite、recipe。</p><p>规则在文件中的顺序无关紧要，唯一和顺序有关的，是确认 default goal 的时候。</p><p>两条例外：句点开头的target 以及pattern rule 不参与 default goal。</p><h2 id="_4-1-示例" tabindex="-1"><a class="header-anchor" href="#_4-1-示例" aria-hidden="true">#</a> 4.1 示例</h2><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo.o</span> <span class="token punctuation">:</span> foo.c defs.h       <span class="token comment"># module for twiddling the frobs</span>
        cc -c -g foo.c
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这是一条规则，</p><ul><li>foo.o 是 target</li><li>foo.c 和 defs.h 是 prerequisite</li><li>cc -c -g foo.c 是 recipe</li></ul><p>这规则说明两件事：</p><ol><li>更新 target 的时机：当 foo.o 不存在，或者 foo.o 比 foo.c、defs.h 中的任何一个更旧时需要生成/更新</li><li>如何生成/更新 target：用命令 cc-c -g foo.c 生成/更新目标 foo.o</li></ol><h2 id="_4-2-规则语法" tabindex="-1"><a class="header-anchor" href="#_4-2-规则语法" aria-hidden="true">#</a> 4.2 规则语法</h2><p>规则的一般形式为：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">targets</span> <span class="token punctuation">:</span> prerequisites
        recipe
        …
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>或者</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">targets</span> <span class="token punctuation">:</span> prerequisites <span class="token punctuation">;</span> recipe
        recipe
        …
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>targets 是文件名列表，空格做分隔符。文件名中可以使用通配符（参见<a href="https://www.gnu.org/software/make/manual/make.html#Wildcards" title="4.4 Using Wildcard Characters in File Names" target="_blank" rel="noopener noreferrer">Using Wildcard Characters in File Names<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>）。 a(m) 形式的 target 对应归档文件 a 中的成员 m（参见<a href="https://www.gnu.org/software/make/manual/make.html#Archive-Members" title="11.1 Archive Members as Targets" target="_blank" rel="noopener noreferrer">Archive Members as Targets<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>)。通常一个规则中写一个 target，但 可以写多个。</p><p>recipe 要求每一行的开头必须是 tab 字符（或者<a href="https://www.gnu.org/software/make/manual/make.html#Special-Variables" title="6.14 Other Special Variables" target="_blank" rel="noopener noreferrer">特殊变量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> .RECIPEPREFIX 值的第一个字符）。 recipe 可以在 prerequisite 的后面新开一行（以 tab 字符开头），或者紧跟着 prerequisite，以分号分隔，二者是一样的效果。 recipe 有不同形式的语法。参见 <a href="https://www.gnu.org/software/make/manual/make.html#Recipes" title="5 Writing Recipes in Rules" target="_blank" rel="noopener noreferrer">Writing Recipes in Rules<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><p>$ 字符用于开启变量引用，所以若要在 target 或 prerequisite 中使用常量 $ 字符，需要两个 $。 若开启了 secondary expansion，就需要四个换一个 $$。</p><p>可以在行末用 \ 续行。makefile 不限制物理行的长度，之所以续行，是为了方便阅读，而非语法要求。</p><blockquote><p>A rule tells make two things: when the targets are out of date, and how to update them when necessary.</p></blockquote><p>target 过期的标准以 prerequisite 的形式呈现，prerequisite 是文件名列表，文件名之间用空格分隔（此处也支持通配符和 archive member）。 当 target 不存在或者比 prerequiiste 中的任意一个更旧（用最后修改时间比较），则 target 是过期的（需要更新的）。 这其中的思想是，target 中的文件是根据 prerequiste 中的文件作为信息来源生成的，所以 prerequisite 中的任意一个文件发生变化， target 都需要重新生成。</p><blockquote><p>The criterion for being out of date is specified in terms of the prerequisites, which consist of file names separated by spaces. A target is out of date if it does not exist or if it is older than any of the prerequisites (by comparison of last-modification times). PS: 根据 <code>if it is older than any of the prerequisites</code>， 如果某个 target 的 prerequisite 为空，那这个 target 是 out of date 当且仅当 target 不存在。 另一方面，如果一个 target 不存在 prerequiste，那就不依赖任何其它东西，那只要生成之后，就不必更新，这也是合理的。</p></blockquote><p>如何生成 target？这就是 recipe 的角色。recipe 中每行都在单独的 shell 中执行（通常是 sh），当然，还有一些附加特性， 参见 <a href="https://www.gnu.org/software/make/manual/make.html#Recipes" title="5 Writing Recipes in Rules" target="_blank" rel="noopener noreferrer">Writing Recipes in Rules<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。</p><h2 id="_4-3-prerequisite-的分类" tabindex="-1"><a class="header-anchor" href="#_4-3-prerequisite-的分类" aria-hidden="true">#</a> 4.3 prerequisite 的分类</h2><p>4.3 Types of Prerequisites</p><p>其实 prerequisite 分两类，normal prerequisite 和 order only prerequisite。</p><p>上一节介绍的其实就是 normal prerequisite，此类 prerequisite 陈述了两件事：</p><ol><li>它隐含说明了相关规则的 recipe 之间的执行的先后顺序：target 的 prerequisite 对应 recipe 要先于 target 自身的 recipe 执行</li><li>它指明了依赖关系：prerequisite 有变化，则对应的 target 就需要更新</li></ol><p>绝大多数情况下，这正是所期望的行为。但有些时候希望只指定规则顺序，而不需要 target 随 prerequisite 的变化而更新。 这可以通过 order-only prerequisite 实现。prerequisite 列表中，管道符后面的 prerequisite 是 order-only prerequisite。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">targets</span> <span class="token punctuation">:</span> normal-prerequisites <span class="token operator">|</span> order-only-prerequisites
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>normal-prerequisite 可以为空。同一个目标可以分多条规则指定 prerequisite，其中的 normal-prerequisite 和 order-only prerequisite 分别叠加，不会混乱。如果同一个 prerequisite 同时出现在 normal prerequisite 和 order-only prerequisite 中，以 normal prerequisite 优先级更高。</p><p>应用场景。 先建立目录，再存入目标文件。目录下，增删文件都会导致目录的最后修改时间变动，但此时不需要重新生成目标文件。 一种处理方案，就是借助 order only prerequisite。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>OBJDIR <span class="token operator">:=</span> objdir
OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>addprefix <span class="token variable">$</span><span class="token punctuation">(</span>OBJDIR<span class="token punctuation">)</span>/,foo.o bar.o baz.o<span class="token punctuation">)</span>

<span class="token symbol"><span class="token variable">$</span>(OBJDIR)/%.o</span> <span class="token punctuation">:</span> %.c
        <span class="token variable">$</span><span class="token punctuation">(</span>COMPILE.c<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT_OPTION<span class="token punctuation">)</span> <span class="token variable"><!--vuepress-ssr-app-->lt;</span>

<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>

<span class="token symbol"><span class="token variable">$</span>(OBJS)</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJDIR<span class="token punctuation">)</span>

<span class="token symbol"><span class="token variable">$</span>(OBJDIR)</span><span class="token punctuation">:</span>
        mkdir <span class="token variable">$</span><span class="token punctuation">(</span>OBJDIR<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>普通依赖， A 依赖 D，且 D 没有其他依赖，则</p><ol><li>执行 make A 时，若 D 不存在，执行 D 对应的 recipe，然后更新 A</li><li>执行 make A 时，若 D 存在，不执行 D 的 recipe，但若 D 比 A 新，则需要更新 A</li></ol><p>对于 order-only 依赖，同样的依赖关系，则</p><ol><li>执行 make A 时，若 D 不存在，执行 D 对应的 recipe，然后更新 A</li><li>执行 make A 时，若 D 存在，不执行 D 的 recipe，但即使 D 比 A 新，也不会因为 D 去更新 A</li></ol><p>Q. 如果 D 有普通依赖，且D的这个依赖更新了呢？ Ans：我猜，D 会因此更新，而 A 不会因此更新。</p><h2 id="_4-4-在文件名中使用通配符" tabindex="-1"><a class="header-anchor" href="#_4-4-在文件名中使用通配符" aria-hidden="true">#</a> 4.4 在文件名中使用通配符</h2><p>单个文件名项可以对应多个文件，只要使用通配符。make 中的通配符包括 * ? [...]，就和 shell 中的语法一样。 make 也支持 ~ 家目录扩展，也和 shell 中的语法一致，在没有家目录概念的系统上（如 DOS和Windows），只消设置 环境变量HOME就同样可以使家目录扩展生效。 ps：显然是扩展为 HOME 变量对应的值。</p><p>在 target 和 prerequisite 中的通配符，由 make 负责扩展，在 recipe 中的通配符由shell负责扩展， 在其它上下文中，当且仅当使用了 wildcard 函数，通配符扩展才会生效。</p><p>要取消通配符字符的特殊含义，用反斜杠转义即可。<code>foo\*bar</code>。</p><p>Q. $ 字符的特殊含义可以用反斜杠处理吗？ Ans: 实测不能。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>file<span class="token operator">=</span>hello.c

<span class="token symbol">hello2</span><span class="token punctuation">:</span> \<span class="token variable">$</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">make</span> hello2
make: *** No rule to <span class="token function">make</span> target <span class="token string">&#39;\hello.c&#39;</span>, needed by <span class="token string">&#39;hello2&#39;</span><span class="token builtin class-name">.</span>  Stop.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果确实取消了 $ 的特殊含义，则应当提示找不到文件 <code>$(file)</code>；如果仍旧替换了变量值， 才会提示找不到文件 <code>\hello.c</code>。</p><h3 id="_4-4-1-示例" tabindex="-1"><a class="header-anchor" href="#_4-4-1-示例" aria-hidden="true">#</a> 4.4.1 示例</h3><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">print</span><span class="token punctuation">:</span> *.c
        lpr -p <span class="token variable">$?</span>
        touch print
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>每次，都会打印自上次打印以来发生变化的 c 文件。print 是一个空文件，参考 <a href="https://www.gnu.org/software/make/manual/make.html#Empty-Targets" title="4.8 Empty Target Files to Record Events" target="_blank" rel="noopener noreferrer">Empty Target Files to Record Events<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><h3 id="_4-4-2-陷阱" tabindex="-1"><a class="header-anchor" href="#_4-4-2-陷阱" aria-hidden="true">#</a> 4.4.2 陷阱</h3><p>make 和 shell 的自动通配符扩展，当没有任何匹配的文件名时，模式会保持不变，处理不当就会出问题。用 wildcard 函数可以解决。 当不存在与模式匹配的文件名时，wildcard 函数会扩展为空。 例如，下面的规则会用工作目录下的所有 .o 文件构建生成可执行程序 foo，当某个 .o 文件发生变化，还会正确更新 foo 文件。 问题来了，如果所有的 .o 文件都被删除了，<code>*.o</code> 就保持不变，foo 会依赖名为 <code>*.o</code> 的文件，这个文件大概率不存在，进而 导致报错 找不到文件 <code>*.o</code>。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo</span><span class="token punctuation">:</span> *.o
  cc -o <span class="token variable">$@</span> <span class="token variable">$^</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>windows 和 dos 系统上，路径分隔符是反斜杠，在这些系统行，make 同时支持两种风格的路径分隔符，如 <code>C:\foo\bar</code> 和 <code>C:/foo/bar</code> 在 make 中是等同的，但如果使用了通配符，就只能使用 unix 风格的路径分隔符， 如 <code>C:/foo/*.c</code>，因为通配符配反斜杠，会被取消通配功能。</p><h3 id="_4-4-3-wildcard-函数" tabindex="-1"><a class="header-anchor" href="#_4-4-3-wildcard-函数" aria-hidden="true">#</a> 4.4.3 wildcard 函数</h3><p>wildcard 语法 <code>$(wildcard patern patern ...)</code>。</p><p>还是上面的例子，正确的方式如下</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>objects<span class="token operator">:=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %.c,%.o, <span class="token variable">$</span><span class="token punctuation">(</span>whildcard *.c<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$^</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>用所有的 .c 文件得到对应的 .o 文件名。 借助隐式规则，用 .c -&gt; .o 的编译，不需要显示列出。</p><h2 id="_4-5-prerequisite-的搜索路径-待续" tabindex="-1"><a class="header-anchor" href="#_4-5-prerequisite-的搜索路径-待续" aria-hidden="true">#</a> 4.5 prerequisite 的搜索路径 待续</h2><p>Searching Directories for Prerequisites</p><p>在比较大的软件系统中，常常会把源代码放置在不同的路径下（ps：比如 .c 和 .h 分开存放）。 make 工具提供目录搜索（directory search）功能，当目录调整目录结构时，无需更改具体 的规则，只需要调整一下搜索路径就行。</p><p>设置搜索路径，有两种方式，VPATH 变量设置全局搜索路径，vpath 指令对不同模式的文件设置不同的搜索路径。</p><p>PS：我可以把目录设置为变量，写入到规则中啊，免得搜索了。 Ans：1. 设置变量，变量就变多了。2. 拆成两个目录，需要两个变量，将来需要改成三个目录的时候就要增加一个变量，还是得修改规则。</p><h3 id="_4-5-1-vpath-变量" tabindex="-1"><a class="header-anchor" href="#_4-5-1-vpath-变量" aria-hidden="true">#</a> 4.5.1 VPATH 变量</h3><p>VPATH 变量指定 make 工具使用的搜索目录列表。通常，这些搜索路径用于搜索不在当前目录下的 prerequisite，而实际上，make 会在这些目录中同时搜索不在当前目录的 target 和 prerequisite。</p><p>如果当前目录下找不到指定的 target 或 prerequisite，make 会在 VPATH 列出的目录中搜索， 如果找到了，make 就把它用作 prerequisite，而规则的 target 或 prerequisite 中，可以 把这个文件视为存在于当前目录下那样指定文件名。</p><p>VPATH 变量指定目录列表，各个目录项用空白或者冒号做分隔符（DOS和Windows下用分号代替冒号）。 make 搜索时，会按照列表中的先后顺序搜索，找到后即不再搜索后续目录。</p><p>假设 src 目录下有源代码文件 foo.c，则如下规则</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>VPATH <span class="token operator">=</span> src<span class="token punctuation">:</span>../headers

<span class="token symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>效果上等同于</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo.o</span> <span class="token punctuation">:</span> src/foo.c
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="_4-5-2-vpath-指令" tabindex="-1"><a class="header-anchor" href="#_4-5-2-vpath-指令" aria-hidden="true">#</a> 4.5.2 vpath 指令</h3><p>vpath 比 VPATH 更灵活，它允许为不同类别的文件指定不同搜索路径。</p><ul><li>vpath pattern directories 为符合指定模式的文件指定搜索路径</li><li>vpath pattern 清空指定模式的搜索目录</li><li>vpath 清空所有模式的搜索目录</li></ul><p>patern 使用 % 作为特殊字符，它匹配任意长度的字符序列（包括零个）。反斜杠转义可以取消 其特殊含义（%）。</p><p>如果一个文件匹配多个 vpath 指定的模式，则这些模式的文本顺序依次应用，使用第一个搜索成功的模式。</p><p>举个例子</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">vpath %.h src/include/</span><span class="token punctuation">:</span><span class="token keyword">include</span>/
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Q. 同时有 VPATH 和 vpath 呢？</p><h3 id="_4-5-3-目录搜索是如何执行的" tabindex="-1"><a class="header-anchor" href="#_4-5-3-目录搜索是如何执行的" aria-hidden="true">#</a> 4.5.3 目录搜索是如何执行的</h3><p>有这么一个问题，规则 <code>foo.o: foo.c</code>，而 foo.c 在 src/ 下搜索到了，那么 make 使用 这个文件的时候 foo.c 的时候是 foo.c 还是 src/foo.c？也就是搜索路径要不要加上去？</p><p>make 有对应的规则</p><ol><li>如果当前目录下找不到 target file，就到搜索目录下查找</li><li>如果找到了，就暂时用实际路径做 target file 的路径，比如用 obj/foo.o 做 target foo.o 的路径</li><li>这个 target file 的所有 prerequisite 也是如此处理</li><li>处理完 target file的所有 prerequisite之后</li></ol><ul><li>若 target 不需要更新，则所有以当前 target file 做 prerequisite 的规则中，使用搜索到的完整路径做 prerequisite 路径名</li><li>若 target 需要更新，则丢弃搜索路径，直接在当前目录下构建 target</li></ul><p>规则略显复杂，但大多数时候这正是所期望的行为。</p><p>其它版本的 make 工具使用更简单的规则：如果在目录搜索过程中找到了 target file，那总是使用搜索到的 pathname。 如果这是期望的行为，只需要把这些搜索目录添加到 GPATH 变量中即可。这个变量的设置规则同VPATH。</p><p>PS: 我补充一个示例。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">vpath</span> %.o build/obj
<span class="token keyword">vpath</span> %.c src
<span class="token symbol">foo</span><span class="token punctuation">:</span> foo.o
  <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span>
<span class="token symbol">foo.o</span><span class="token punctuation">:</span> foo.c
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>执行命令 <code>make foo</code>，如果存在文件 build/obj/foo.o 且不需要更新，则 foo: foo.o 中，<code>$^</code> 会变成 build/obj/foo.o；如果 文件不存在，则会使用 src/foo.c 编译生成 ./foo.o，然后规则 foo: foo.o 中 <code>$^</code> 会变成 foo.o。</p><p>PS：</p><h3 id="_4-5-4-书写可以适配-directory-search-的-recipe" tabindex="-1"><a class="header-anchor" href="#_4-5-4-书写可以适配-directory-search-的-recipe" aria-hidden="true">#</a> 4.5.4 书写可以适配 Directory Search 的 recipe</h3><p>一句话，需要借助自动变量。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
        cc -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span>
VPATH <span class="token operator">=</span> src<span class="token punctuation">:</span>../headers
<span class="token symbol">foo.o</span> <span class="token punctuation">:</span> foo.c defs.h hack.h
        cc -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable"><!--vuepress-ssr-app-->lt;</span> -o <span class="token variable">$@</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_4-5-5-directory-search-和-implicit-rule" tabindex="-1"><a class="header-anchor" href="#_4-5-5-directory-search-和-implicit-rule" aria-hidden="true">#</a> 4.5.5 Directory Search 和 implicit rule</h3><p>谈到目录搜索，隐式规则和显式规则一样会尝试搜索。</p><p>比如，如果没有明确指定生成 foo.o 的规则，会尝试隐式规则，先查看当前目录是否存在 .c 文件， 如果没有，会查看VPATH、vpath 设置定目录中有没有，如果有，就匹配上了。</p><h3 id="_4-5-6-directory-search-和链接库-略" tabindex="-1"><a class="header-anchor" href="#_4-5-6-directory-search-和链接库-略" aria-hidden="true">#</a> 4.5.6 Directory Search 和链接库 略</h3><p>对于链接库，make 会做特殊处理。 ps：用到的时候再详查手册。</p><p>比如，要用到 curses 库，不是指定 libcurses.so，而是以 -lcurses 的形式指定依赖，make会知道 这是库文件依赖，就会搜索 libcurse.so，找不到会继续尝试 libcurse.a。 还会尝试各种系统内置路径……</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo</span> <span class="token punctuation">:</span> foo.c -lcurses
        cc <span class="token variable">$^</span> -o <span class="token variable">$@</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_4-6-phony-target" tabindex="-1"><a class="header-anchor" href="#_4-6-phony-target" aria-hidden="true">#</a> 4.6 Phony target</h2><blockquote><p>A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.</p></blockquote><p>伪目标有两个好处：</p><ol><li>明确某个 target 只是一个动作，不代表实际的文件</li><li>因此可以提升性能：不会对伪目标搜索隐式规则，不会对伪目标测试对应的文件的修改时间</li></ol><p>伪目标不应当作为真实目标的依赖，不然的话，每次检测这个真实目标，它都需要执行。</p><p>Q. 真这么做了，会如何？</p><p>伪目标可以有依赖，比如，常常用伪目标 all 一次性构建项目的所有程序。 伪目标不会传递：伪目标的 prerequisite 不会自动成为伪目标，除非明确声明为伪目标。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">all</span> <span class="token punctuation">:</span> prog1 prog2 prog3
<span class="token builtin">.PHONY</span> <span class="token punctuation">:</span> all

<span class="token symbol">prog1</span> <span class="token punctuation">:</span> prog1.o utils.o
        cc -o prog1 prog1.o utils.o

<span class="token symbol">prog2</span> <span class="token punctuation">:</span> prog2.o
        cc -o prog2 prog2.o

<span class="token symbol">prog3</span> <span class="token punctuation">:</span> prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>伪目标可以作为另一个伪目标的依赖，此时作为 prerequisite 的伪目标扮演子程序的角色。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.PHONY</span><span class="token punctuation">:</span> cleanall cleanobj cleandiff

<span class="token symbol">cleanall</span> <span class="token punctuation">:</span> cleanobj cleandiff
        rm program

<span class="token symbol">cleanobj</span> <span class="token punctuation">:</span>
        rm *.o

<span class="token symbol">cleandiff</span> <span class="token punctuation">:</span>
        rm *.diff
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_4-7-既没有-recipe-又没有-prerequisite-的规则" tabindex="-1"><a class="header-anchor" href="#_4-7-既没有-recipe-又没有-prerequisite-的规则" aria-hidden="true">#</a> 4.7 既没有 recipe 又没有 prerequisite 的规则</h2><p>如果一个规则既没有 prerequisite 也没有 recipe，且此规则的 target 不对应实际存在的文件， 则每次执行此规则的时候， make 都认为此规则的 target 处于已更新状态。一个推论是， 所有依赖此target的规则，其 recipe 总是会执行。</p><blockquote><p>If a rule has no prerequisites or recipe, and the target of the rule is a nonexistent file, then make imagines this target to have been updated whenever its rule is run. This implies that all targets depending on this one will always have their recipe run.</p></blockquote><p>下面这个例子，和使用 <code>.PHONY: clean</code> 的效果是一样的，但使用 .PHONY 更能明确表达意图， 同时性能更高。不过有些 make 工具不支持 .PHONY 伪目标，所以可以用这个方式代替。 FORCE 这个名称没有特殊含义，只不过大家都这么用。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">clean</span><span class="token punctuation">:</span> FORCE
        rm <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token symbol">FORCE</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Q. 原文 <code>Rules without Recipes or Prerequisites</code>，如何理解？</p><ol><li>是指 既没有 recipe 又没有 prerequisite？</li><li>还是指如下任意一种情形： - 没有 recipe，但有 prerequisite - 有 recipe，但没有 prerequisite - 既没有 recipe，又没有 prerequisite Ans：按方式 1 理解。</li></ol><p>附：英语用法 下面四语：</p><ul><li>without A and B</li><li>without A and without B</li><li>without A or B</li><li>without A or without B</li></ul><p>第一种表达方式、第二种表达方式和第三种表达方式意思相同，都是A 和 B 都没有。 第四种表达方式是“没有 A 或没有 B”，就是“没有 A 而有 B，或没有 B 而有 A ”。 说 A 和 B 都没有不该用第四种表达方式。</p><h2 id="_4-8-用空的target文件记录事件" tabindex="-1"><a class="header-anchor" href="#_4-8-用空的target文件记录事件" aria-hidden="true">#</a> 4.8 用空的target文件记录事件</h2><p>这种用法是伪目标的变种。这里对应的目标文件可以实际存在，文件内容无所谓，一般是空文件。 文件的最后修改时间才是重要的。这种 target 应当有 prerequisite，如果 prerequisite 是空的，这条规则就没有意义。</p><p>下面这个例子，make print 用于打印自上次打印之后变化了的文件。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">print</span><span class="token punctuation">:</span> foo.c bar.c
        lpr -p <span class="token variable">$?</span>
        touch print
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_4-9-有特殊意义的内置target-部分" tabindex="-1"><a class="header-anchor" href="#_4-9-有特殊意义的内置target-部分" aria-hidden="true">#</a> 4.9 有特殊意义的内置target : 部分</h2><p>有些 target 的名称有特殊含义，如果出现在 makefile 中。</p><p>用到的时候查手册。</p><ul><li><p>.PHONY 此目标的依赖叫做伪目标</p></li><li><p>.SECONDEXPANSION 如果定义了此目标，从定义出往后，所有的规则的prerequisite都开启二此扩展。</p></li><li><p>.SILENT 作为此目标依赖的target，执行时不会回显它的 recipe .SILENT 的 recipe 被忽略。如果 .SILENT 没有依赖，则所有规则的 recipe 都不回显。 更精巧的控制，参考 <a href="https://www.gnu.org/software/make/manual/make.html#Echoing" title="5.2 Recipe Echoing" target="_blank" rel="noopener noreferrer">Recipe Echoing<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p></li><li><p>.ONESHELL 只要定义了这个 target。所有的规则都使用单进程，也就是 每个规则的 recipe 在一个 shell 进程中执行。默认是 recipe 的每一行使用一个shell进程。</p></li></ul><p>ps：特殊规则都以句点开头，并非语法规则的要求，而是沿袭了相应的传统。参考手册。</p><h2 id="_4-10-一个规则多个-target" tabindex="-1"><a class="header-anchor" href="#_4-10-一个规则多个-target" aria-hidden="true">#</a> 4.10 一个规则多个 target</h2><p>一条显式规则可以写多个 target，这多个 target 的关系分为两种，独立的 target 和 grouped target(组合target)，区分这二者的方式是 target 列表后的分隔符，普通冒号分隔符 是独立target，<code>&amp;:</code>是组合target，&amp; 的含义是 all。</p><p>独立 target 没有特别的意义，可以看作一种简写方式，这种方式等价于 target 分开写， 然后重复 prerequisite 和 recipe 部分。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo.o bar.o baz.o</span><span class="token punctuation">:</span> common.h
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>等价于</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo.o</span><span class="token punctuation">:</span> common.h
<span class="token symbol">bar.o</span><span class="token punctuation">:</span> common.h
<span class="token symbol">baz.o</span><span class="token punctuation">:</span> common.h
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>组合 target 则不同，它告诉 make，只要执行此规则对应的 recipe，同一组内的所有 target 都会被更新，这在计算依赖关系的时候，make 要考虑到。这有什么用处呢？比如，可能单个命令 会一次性生成多个文件，就可以用组合 target 告诉 make 这些文件直接的关联关系。</p><p>为了演示一下，如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo bar biz &amp;</span><span class="token punctuation">:</span> baz boz
    echo <span class="token variable">$^</span> &gt; foo
    echo <span class="token variable">$^</span> &gt; bar
    echo <span class="token variable">$^</span> &gt; biz
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>要注意的是，组合 target 中，自动变量 <code>$@</code> 的展开结果是触发 recipe 执行的那个 target， 而不是通常期望的每次展开为一个 target。</p><p>组合 target 必须包含 recipe。组合 target 中的某个 target 还可以同时是另一个规则 中的独立 target，只要另外的那个规则没有 recipe。</p><p>组合 target 中的 target 只需出现在一个组内，只需有一个 recipe。 如果作为组合 target 的 target 同时作为另一个规则的的独立 target 或者另一个带有 recipe 的规则的组合 target 的成员，则会给出警告最终后面的 recipe 生效，另外， 还会把这个 target 从前一个组合中删除，只作为后面组合 target 的成员。</p><p>若要让一个 target 同时作为多个组合target 的成员，要用 double colon grouped target 语法 <code>&amp;::</code>。</p><h2 id="_4-11-一个-target-多个规则" tabindex="-1"><a class="header-anchor" href="#_4-11-一个-target-多个规则" aria-hidden="true">#</a> 4.11 一个 target 多个规则</h2><p>多条规则可以有共同的 target，对于这个 target 来说，它的 prerequisite 是所有这些规则 的 prerequisite 拼接到一起组合而来。</p><p>一个 target 只许有一个 recipe，如果找到了多个规则都有 recipe，则取最后一个 recipe 作为最终的 recipe，同时会给出报错信息。一种例外情形是 target 以句点开头，但这中不规范 的行为是为了兼容别的版本的 makefile。如果确实希望用多个规则共同给同一个 target 提供 完整的recipe，使用 <a href="https://www.gnu.org/software/make/manual/make.html#Double_002dColon" title="4.13 Double-Colon Rules" target="_blank" rel="noopener noreferrer">double colon rule<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。</p><p>这种语法的一种场景如下，也就是一次性为一组文件指定少量的公共依赖项。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>objects <span class="token operator">:=</span> foo.o bar.o

<span class="token symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> common.h
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>另一种常用情景如下，可以通过命令行指定额外的依赖。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>extral_deps<span class="token operator">:=</span>
<span class="token symbol">foo.o</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>extral_deps<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>调用 make 命令时，<code>make extral_deps=bar.h</code>，则 foo.o 会有额外依赖 bar.h，而 单纯执行 <code>make</code> 命令则不会。</p><p>如果没有显式规则为 target 提供 recipe，make 会尝试搜索隐式规则。</p><h2 id="_4-12-静态模板规则" tabindex="-1"><a class="header-anchor" href="#_4-12-静态模板规则" aria-hidden="true">#</a> 4.12 静态模板规则</h2><p>static pattern rules</p><p>静态模板规则是这样的规则，指定多个 target，基于每个 target 对应不同的 prerequisite。 它比多个 target 的普通规则更通用，因为后者的所有 target 的 prerequisite 相同， 而静态模板规则的 target 对应的 prerequisite 是类似而不完全相同。</p><h3 id="_4-12-1-语法" tabindex="-1"><a class="header-anchor" href="#_4-12-1-语法" aria-hidden="true">#</a> 4.12.1 语法</h3><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">targets ...</span> <span class="token punctuation">:</span> target-pattern <span class="token punctuation">:</span> prereq-patterns ...
    recipe...
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>objects<span class="token operator">:=</span>foo.o bar.o baz.o

<span class="token symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c
      <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable"><!--vuepress-ssr-app-->lt;</span> -o <span class="token variable">$@</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>targets 列出所有 target，与普通规则无异。target-pattern 指定了如何从 target 中提取 其中的模式匹配的部分，这一部分叫做 stem，通常，target-pattern 中有且仅有一个 % 做通 配符，它可以匹配任意长度的字符串，pattern 的剩余部分要求和 target 的剩余部分精确匹配。 prereq-pattern 指出如何利用 stem 构造对应的prerequisite。prereq-pattern 也包含通配 符 %，把 % 替换为 stem 得到最终的 prerequisite。</p><p>prereq-pattern 可以不包含通配符，此时所有的 target 使用这同一个 prerequisite。</p><p>这两个 pattern 中的通配符 % 可以用反斜杠转义 <code>\%</code>，使其失去通配效果，进一步，反斜杠可以把 反斜杠转义，使其不至于将 % 的通配效果取消 <code>\\%</code>。</p><p>如果某个 target 不能匹配 target-pattern，会给出警告信息。用 filter 函数，可以把不匹配的 target 过滤掉。比如</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>files<span class="token operator">:=</span>foo.o bar.o biz.elc

<span class="token symbol"><span class="token variable">$</span>(filter %.o, <span class="token variable">$</span>(files))</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c
        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable"><!--vuepress-ssr-app-->lt;</span> -o <span class="token variable">$@</span>
<span class="token symbol"><span class="token variable">$</span>(filter %.elc, <span class="token variable">$</span>(files))</span><span class="token punctuation">:</span>%.elc<span class="token punctuation">:</span> %.el
        emacs -f batch-byte-compile <span class="token variable"><!--vuepress-ssr-app-->lt;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果一个 target 同时匹配多条静态模板规则，会报错。</p><h3 id="_4-12-2-与隐式规则对比" tabindex="-1"><a class="header-anchor" href="#_4-12-2-与隐式规则对比" aria-hidden="true">#</a> 4.12.2 与隐式规则对比</h3><p>隐式规则生效的条件：当且仅当没有其它规则能为某个 target 提供对应的 recipe，且存在对应的 prerequisite。 如果多个隐式规则同时匹配上，就看它们的先后顺序，在前面的规则先生效。</p><p>静态模板规则则不然，它可以看作是显式规则的简写形式。只匹配明确列出的 target。</p><p>静态模板规则比隐式规则更靠谱。比如，如果无法确定 Makefile 所在的目录会有哪些无关的文件， 就有可能存在某些文件，使得意料之外的某个隐式规则生效了。</p><h2 id="_4-13-双冒号规则" tabindex="-1"><a class="header-anchor" href="#_4-13-双冒号规则" aria-hidden="true">#</a> 4.13 双冒号规则</h2><p>double-colon rules</p><p>双冒号规则的 target 列表后用 <code>::</code> 做分隔符，双冒号是显式规则的一种。 普通的显式规则的 target 用<code>:</code>分隔。</p><p>当一个 target 出现在多个 rule 中时，双冒号规则和普通规则的处理逻辑相差很大。</p><p>一个 target 的所有显式规则的类型必须相同：要么都是普通规则，要么都是双冒号规则。</p><p>同一个 target 的多条双冒号规则之间互相独立，那个规则的 prerequisite 发生了变化就执行 这个规则对应的 recipe。如果某个双冒号规则没有 prerequisite，那这个规则总是会执行，即使 对应的 target 已经存在也执行。所以同一个 target 的双冒号规则可能执行 0 条、若干条、全部执行。</p><p>若同一个 target 的有多个双冒号需要更新，按先后顺序依次执行。但是，双冒号规则适用的场景 中，不应当依赖规则的执行顺序。</p><p>双冒号规则的行为不大合理，应用场景也很少，一种适用但很稀少的场景是，一个目标，不同的依赖 发生变化，要使用不同的命令更新。</p><p>如果某个双冒号规则没有 recipe，会尝试用隐式规则去匹配。</p><h2 id="_4-14-自动生成依赖" tabindex="-1"><a class="header-anchor" href="#_4-14-自动生成依赖" aria-hidden="true">#</a> 4.14 自动生成依赖</h2><p>Generating Prerequisites Automatically</p><p>说的是，c 语言头文件依赖关系，可以借助编译器的 -M 结合 GNU make 的 remake 机制自动生成。如果是 GNU 的 C 编译器，还可以用 -MM 替换 -M。</p><p>在没有 remake 机制的 make 工具下，常见的实践方式是先 make depend，把所有的头文件依赖 生成到名为 depend 的文件中，然后在 Makefile 中有一条 -include depend 指令。</p><h1 id="_5-规则中的-recipe" tabindex="-1"><a class="header-anchor" href="#_5-规则中的-recipe" aria-hidden="true">#</a> 5 规则中的 recipe</h1><p>Writing Recipes in Rules</p><h2 id="_5-1-语法" tabindex="-1"><a class="header-anchor" href="#_5-1-语法" aria-hidden="true">#</a> 5.1 语法</h2><p>Recipe Syntax</p><p>make 文件本身是一种语法，而 recipe 则是 shell 脚本的语法，一个文件有两种截然不同的语法， 这是 Makefile 的一个不同寻常的地方。make 本身并不理解 shell 脚本，仅在把内容传递给 shell 之前做少量的处理。</p><p>PS：shell 脚本还能内嵌别的语言片段呢。</p><p>recipe 中的每一行必须以 tab 字符开头（或者特殊变量 .RECIPEPREFIX 指定的第一个字符）， 唯一的例外是recipe的第一行，它可以出现在 target-and-prerequisite 的末尾，用分号分隔。 任何在规则上下文中且以 tab 字符开头的行都是 recipe line，recipe line 之间可以有 空白行和注释行，它们被直接忽略。规则上下文是指 target-and-prerequisite 之后，下一个 规则定义或者变量赋值之前，这之间的区域。</p><p>有如下结论</p><ul><li>tab 字符开头的空行不是空白，而是 empty recipe</li><li>recipe 中的注释不是makefile中的注释，它会被原样传递给 shell</li><li>rule context 下，以 tab 字符开头的变量定义会被传递给shell，而非makefile中的变量定义</li><li>rule context下，以tab字符开头的条件语句，会被传递给shell，而非makefile的条件语句</li></ul><h3 id="_5-1-1-recipe-中的续行" tabindex="-1"><a class="header-anchor" href="#_5-1-1-recipe-中的续行" aria-hidden="true">#</a> 5.1.1 recipe 中的续行</h3><p>Splitting Recipe Lines</p><p>makefile 对 recipe 执行的为数不多的处理过程，其中一个就是续行。</p><p>makefile 中，recipe 部分的续行，其含义仍然是多个物理行合并为一个逻辑行，不同的是</p><ul><li>不会把斜杠+换行替换为空白，而是保留并传递给 shell</li><li>如果 斜杠+换行 的下一行的开头是 RECIPEPREFIX 字符，make 会把这个字符删除（且仅删除这一个字符）</li></ul><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">all</span> <span class="token punctuation">:</span>
        <span class="token operator">@</span>echo no\
space
        <span class="token operator">@</span>echo no\
        space
        <span class="token operator">@</span>echo one \
        space
        <span class="token operator">@</span>echo one\
         space
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>对应的输出如下</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>nospace
nospace
one space
one space
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>PS：这个示例还表明，recipe 中的续行符的下一行不必须以 RECIPEPREFIX 字符开头。 PPS：续行符，指 斜杠+换行</p><p>PS：由此，要使用续行使得make在一个shell中一个recipe内的执行多个命令，就要在每个命令后加上分号，给shell看。</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>var-kept:
    export foo=bar; \
    echo &quot;foo=[$foo]&quot;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果希望让 make 把续行符替换成空格，一种方式是用makefile的变量做一次中转</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>HELLO <span class="token operator">=</span> <span class="token string">&#39;hello \
world&#39;</span>

<span class="token symbol">all</span> <span class="token punctuation">:</span> <span class="token punctuation">;</span> <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>shell 接收到的命令就会变成 <code>echo hello world</code>。</p><h3 id="_5-1-2-在-recipe-中使用变量" tabindex="-1"><a class="header-anchor" href="#_5-1-2-在-recipe-中使用变量" aria-hidden="true">#</a> 5.1.2 在 recipe 中使用变量</h3><p>makefile 对 recipe 进行的另一个处理是变量替换。变量替换，在读取完所有的 makefile 并 确定了 target 为 out of date 后才进行，也就是说，不需要更新的 target，其对应的 recipe 不会发生变量扩展。</p><p>首先，recipe 中的变量引用和函数引用语法与其它地方相同，都是 $(xxx ) 的形式。其次， 大多数shell（包括默认/bin/sh），也使用 $ 作为变量引用标志，所以，要让 $ 出现在 shell 中，就得用两个 $，和其它地方一样。编写 makefile 的时候一定要搞清楚要引用的是 makefile 中的变量还是 shell 变量。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>LIST <span class="token operator">=</span> one two three
<span class="token symbol">all</span><span class="token punctuation">:</span>
        for i in <span class="token variable">$</span><span class="token punctuation">(</span>LIST<span class="token punctuation">)</span><span class="token punctuation">;</span> do \
            echo <span class="token variable">$i;</span> \
        done
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_5-2-recipe-的回显" tabindex="-1"><a class="header-anchor" href="#_5-2-recipe-的回显" aria-hidden="true">#</a> 5.2 recipe 的回显</h2><p>默认，make 会输出执行的每一行 recipe。如果某行以 @ 开头，这一行就不会回显。通常，@字符 用于关闭单纯输出信息的命令</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo</span><span class="token punctuation">:</span>
      <span class="token operator">@</span>echo hello
      <span class="token comment"># do something</span>

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>-n --just-print 选项，用于输出要执行的命令而不真正执行，这个选项在debug的时候很有帮助。 这个选项输出的时候，以@开头的recipe line 同样会被输出。</p><p>选项 -s --silent 用于关闭所有回显，就好像每个 recipe line 都以 @ 字符开头似的。 特殊 <code>.SILENT:</code>，当它的 prerequisite 为空时，效果等价于 -s。</p><p>Q. @ 和续行？ Ans：@ 对逻辑行关闭回显，所以，续行符后面的一样不会回显。</p><h2 id="_5-3-执行-recipe" tabindex="-1"><a class="header-anchor" href="#_5-3-执行-recipe" aria-hidden="true">#</a> 5.3 执行 recipe</h2><p>当需要执行规则的 recipe 以更新 target 时，recipe 中的每一行，make 都用一个新的 子shell进程执行，除非设置了 <code>.ONESHELL:</code> 这个特殊 target。</p><p>一个直白的推论是，设置环境变量、执行 cd 命令切换目录等特定于shell进程的操作，对后续的 recipe 行不生效。如果要 cd 命令对下一条shell语句生效，把他们合并到一行，如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo</span> <span class="token punctuation">:</span> bar/lose
        cd <span class="token variable">$(&lt;D)</span> &amp;&amp; gobble <span class="token variable">$(&lt;F)</span> &gt; ../<span class="token variable">$@</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_5-3-1-使用一个-shell" tabindex="-1"><a class="header-anchor" href="#_5-3-1-使用一个-shell" aria-hidden="true">#</a> 5.3.1 使用一个 shell</h3><p>有时候，确实需要用单个shell执行单个 recipe 中的所有行。好处有两点，一是提升性能，因为 创建的子进程少了，二是保留 recipe 的换行符。</p><p>如果 makefile 的任何位置设置了特殊 target <code>.ONESHELL:</code>，每个 target 的 recipe 的所有 行都会在一个子 shell 中执行，同时，recipe 内的换行符保留。</p><p>例如，下面的代码段行为可以符合预期。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.ONESHELL</span><span class="token punctuation">:</span>
<span class="token symbol">foo</span> <span class="token punctuation">:</span> bar/lose
        cd <span class="token variable">$(@D)</span>
        gobble <span class="token variable">$(@F)</span> &gt; ../<span class="token variable">$@</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当设置了 <code>.ONESHELL:</code>，会检查 recipe 的第一行（且仅检查第一行），并在把recipe传递给 SHELL 之前移除第一行开头的特殊字符（@、+、-）。 如下，这个例子中，意图用给 perl 传入一个两行构成的程序，但因为使用了 <code>.ONESHELL:</code>， 第一行的变量定义 @f 的 @ 会被移除，这是语法错误。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.ONESHELL</span><span class="token punctuation">:</span>
SHELL <span class="token operator">=</span> /usr/bin/perl
.SHELLFLAGS <span class="token operator">=</span> -e
<span class="token symbol">show</span> <span class="token punctuation">:</span>
        <span class="token operator">@</span>f <span class="token operator">=</span> qw<span class="token punctuation">(</span>a b c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        print <span class="token string">&quot;@f\n&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以在 recipe 的地一样插入一行注释（或类似的方式）避开这一问题</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.ONESHELL</span><span class="token punctuation">:</span>
SHELL <span class="token operator">=</span> /usr/bin/perl
.SHELLFLAGS <span class="token operator">=</span> -e
<span class="token symbol">show</span> <span class="token punctuation">:</span>
        <span class="token comment"># Make sure &quot;@&quot; is not the first character on the first line</span>
        <span class="token operator">@</span>f <span class="token operator">=</span> qw<span class="token punctuation">(</span>a b c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        print <span class="token string">&quot;@f\n&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>或者</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.ONESHELL</span><span class="token punctuation">:</span>
SHELL <span class="token operator">=</span> /usr/bin/perl
.SHELLFLAGS <span class="token operator">=</span> -e
<span class="token symbol">show</span> <span class="token punctuation">:</span>
        my <span class="token operator">@</span>f <span class="token operator">=</span> qw<span class="token punctuation">(</span>a b c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        print <span class="token string">&quot;@f\n&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>作为一个特例，若 SHELL 是 POSIX 风格的 shell，则所有的 recipe 行开头的特殊字符都会移除。 这是为了让已有的 makefile 可以直接使用 .ONESHELL 特性，而不破坏其功能。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin">.ONESHELL</span><span class="token punctuation">:</span>
<span class="token symbol">foo</span> <span class="token punctuation">:</span> bar/lose
        <span class="token operator">@</span>cd <span class="token variable">$(@D)</span>
        <span class="token operator">@</span>gobble <span class="token variable">$(@F)</span> &gt; ../<span class="token variable">$@</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>即使如此，还会有其它问题，例如，某个中间的命令失败，make 无法捕获失败信息，对应的解决 方案是设置 <code>.SHELLFLAGS=-e</code>，这样，shell会在遇到失败命令后立即退出，但这本身会改变 recipe 的行为。总而言之，使用 .ONEHSELL，就必须要在 recipe 中做出对应的变化。</p><h3 id="_5-3-2-选择-shell" tabindex="-1"><a class="header-anchor" href="#_5-3-2-选择-shell" aria-hidden="true">#</a> 5.3.2 选择 shell</h3><p>变量 SHELL 指定了 make 执行 recipe 所用的 shell，如果没有在makefile中设置此变量， make 使用 /bin/sh 执行 recipe。变量 .SHELLFLAGS 指定传递给 shell 的选项，其默认值是 -c，POSIX 模式下是 -ec。</p><p>PS：或者说，make 变量 SHELL 的默认值是 /bin/sh。见后文demo。</p><p>不同于其他变量，SHELL 变量不会继承环境变量中的 SHELL。这是因为 Linux shell 基本都会设置 变量 SHELL 表明当前的 shell 类型，若 makefile 受这个环境变量的影响，就它不稳定了。</p><p>同时，recipe 中继承的环境变量 SHELL，不是 makefile 的SHELL变量，而是真实的用户变量 SHELL。</p><p>在 MS-DOS 和 MS-Windows 上，makefile 反而又会用环境变量 SHELL 作为自己的 SHELL 变量， 这是因为 dos 系统一般不设置这个变量，如果设置了，大概率就是为了给 makefile 指定 shell。在 MS-DOS 上，如果不方便设置环境变量 SHELL，可用环境变量 MAKESHELL 指定 makefile 中的 SHELL，它比 SHELL 优先级更高。</p><p>demo：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">cat</span> Makefile

<span class="token comment"># SHELL 的值</span>
<span class="token variable"><span class="token variable">$(</span>info $<span class="token punctuation">{</span><span class="token environment constant">SHELL</span><span class="token punctuation">}</span><span class="token variable">)</span></span>

hello:<span class="token punctuation">;</span> @echo <span class="token variable">${<span class="token environment constant">SHELL</span>}</span>,$<span class="token variable">${<span class="token environment constant">SHELL</span>}</span>

$ <span class="token function">make</span>
/bin/sh
/bin/sh,/bin/bash
$ <span class="token function">make</span> -e <span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>f
f
make: f: No such <span class="token function">file</span> or directory
make: *** <span class="token punctuation">[</span>Makefile:5: hello<span class="token punctuation">]</span> Error <span class="token number">127</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>也就是说，同样的变量，SHELL，有两个。</p><h4 id="在dos和windows中选择shell-略" tabindex="-1"><a class="header-anchor" href="#在dos和windows中选择shell-略" aria-hidden="true">#</a> 在DOS和windows中选择shell （略)</h4><h2 id="_5-4-并发执行" tabindex="-1"><a class="header-anchor" href="#_5-4-并发执行" aria-hidden="true">#</a> 5.4 并发执行</h2><p>默认，make 顺序执行 recipe，如果指定了 -j 选项，make 会并发执行 recipe。 -j 后跟整数，则限制并发的 recipe 数，如果不跟整数，则表示不限制。如果不指定 -j 选项， 等效于 -j 1，也就是默认行为。</p><p>-j N 指定的是同时执行的 recipe 的数量，这叫做 job slots。</p><p>并发执行的时候，递归调用 make 需要做些处理，否则会有问题，详情参考 <a href="https://www.gnu.org/software/make/manual/make.html#Options_002fRecursion" title="5.7.3 Communicating Options to a Sub-make" target="_blank" rel="noopener noreferrer">Communicating Options to a Sub-make<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><p>如果 recipe 执行失败，且未忽略错误，则 make 会终止此 recipe 的执行（也就是不会继续执行后面的行）。 如果 recipe 执行失败，同时又未指定 -k --keep-going 选项，则 make 会终止执行。 如果 make 因某种原因要终止执行（包括收到 SIGINT信号），同时有正在执行的子进程，make 会等待这些子进程执行完毕。</p><p>选项 -l --max-load 用于指定系统负载限制。当系统负载高于此水平且make已经有至少一个 job 在运行，make 就不会开启 新的job，除非系统负载降低到指定的限制下。默认，没有限制。</p><h3 id="_5-4-1-并发时的输出" tabindex="-1"><a class="header-anchor" href="#_5-4-1-并发时的输出" aria-hidden="true">#</a> 5.4.1 并发时的输出</h3><p>默认，recipe 输出的信息会被立即输出到标准输出上，在并发执行的时候，多个 recipe 之间的 输出会混杂在一起，甚至混在在一行中，使得阅读困难。</p><p>用 -o --output-sync 选项可以解决这个问题。指定 -o 选项后，make 会缓存每个 recipe的输出， 等 recipe 执行完毕后再一次性打印出来，确保其完整。指定 -o 选项后，多个同时执行的 递归 make 会协调一致，确保不会使输出混乱。</p><p>如果开启了工作目录打印（--print-directory选项），每组信息的开头和结束都会附加上一条 enter/leave 消息。 要关闭这个消息，使用 --no-print-directory 选项，在 MAKEFLAGS 中设置。</p><p>Q. 为什么是在这个变量中设置？</p><p>输出同步（-o选项）有四个粒度</p><ul><li>none： 这是未指定 -o 选项时的默认行为。立即打印产生的输出，也就是没有任何同步措施</li><li>line： 以行作为分组，每产生一行就输出一行。如果一个 recipe 多行输出，它们可能会和其recipe输出的行混合。</li><li>target：这是指定 -o 选项时的默认行为。每个 target 产生的输出作为一组。当一个target的recipre执行完毕后，一次性输出对应的消息。</li><li>recurse：每个make递归调用作为一个分组，并在 <blockquote><p>Output from each recursive invocation of make is grouped and printed once the recursive invocation is complete.</p></blockquote></li></ul><p>不同同步粒度，make 的执行时间不会变化，变化的只是输出内容的方式。</p><p>对于不含递归make调用的recipe来说，target 和 recurse 效果相同。</p><p>设置 recurse 模式，如果 recipe 中有递归的make调用，则输出也和 target 一样，需要等整个 recipe 调用完成（从而整个递归make执行 完毕）才会一次性不中断打印所有输出，这样的好处是日志清晰，坏处是如果递归make执行时间较长，会输出就需要等待。如果是离线执行， 而后查看输出，显然这种模式更合适。</p><p>但如果是要实时查看输出，就有点头疼了。使用 target 模式，make 会检测到 recipe 中的递归make调用，并对这些包含递归make 调用的行关闭同步处理，而递归make自己会按 target 模式处理自己的 recipe 输出同步问题，需要指出递归调用make的recipe行， 如果在调用make之前有输出信息，这些信息不会得到同步。<code>echo hello &amp;&amp; $(MAKE) -f some-makefile</code>。</p><p>line 模式，适合前端实时监控输出，用于判断每个recipe开始和结束。</p><p>有些程序会根据输出到控制台还是文件（通常称为交互模式和非交互模式）使用不同的输出，如交互模式下生成彩色输出。 因为 make 的同步模式会缓存输出，所以程序会认为处于非交互模式，而实际上，可以视为交互模式。</p><h3 id="_5-4-2-并发时的输入" tabindex="-1"><a class="header-anchor" href="#_5-4-2-并发时的输入" aria-hidden="true">#</a> 5.4.2 并发时的输入</h3><p>两个进程无法同时从同一个设备读取输入。并发执行时，make 只开启一个正在执行的 recipe 的输入， 而关闭其它所有 recipe 的的输入，如果这些 recipe 尝试从 stdin 读取输入，就会报错。</p><p>无法预知哪个 recipe 会得到输入。make 是这么做的，第一个执行的 recipe 得到输入，其它 同时执行的 recipe 得不到输入，等第一个得到输入的 recipe 执行完毕后，紧跟着执行的那个 recipe 得到输入。</p><p>如果有更好的处理方法，我们将尝试改进。在此之前，并行执行的时候，请务必不要依赖 recipe 读取输入。非并发执行的时候可以在 recipe 中读取标准输入。</p><h2 id="_5-5-recipe-中的错误" tabindex="-1"><a class="header-anchor" href="#_5-5-recipe-中的错误" aria-hidden="true">#</a> 5.5 recipe 中的错误</h2><ul><li>make的错误检测</li><li>忽略错误：-、-i、动机</li><li>keep going：机制，原因</li><li>错误时的删除</li></ul><p>执行的 recipe 的时候，每执行一行，make 检查其退出状态，如果执行成功，make 在新的shell进程 中执行下一行，如此继续，直到最后一行也成功执行，整个recipe执行完毕。</p><p>如果某一行执行失败，make 终止当前 recipe 的执行，通常，其它所有待执行的 recipe 也一并终止。</p><p>有些行，执行失败并不代表出现问题，比如 mkdir foo 命令是为了确保目录 foo 存在，如果目录 已经存在，执行此命令会失败，但这个失败不代表出错，可以继续执行。这种情况，可以在命令的 开头添加特殊字符<code>-</code>，比如 <code>-mkdir foo</code>，移交shell执行的时候，make 会删除开头的特殊字符。</p><p>执行的时候使用 -i --ignore-errors，会忽略所有recipe的所有行的错误，就好像在每个命令的 开头添加了特殊字符 <code>-</code>。在 makefile 中使用不含 prerequisite 的 <code>.IGNORE:</code> 特殊目标， 效果和 -i 选项等同。</p><p>当某个 recipe 的某个命令执行失败，且没有忽略此行命令的错误（-i或者-字符），表明此 recipe 对应的 target 无法成功更新，同时所有直接或间接依赖于此 target 的那些 target 也无法更新。 所以 make 会立即停止所有这些 target 对应的 recipe 的执行。</p><p>通常，这时候 make 会终止整个执行过程。但如果指定了 -k --keep-going，make 会在遇到错误 后继续执行其它可以执行的 recipe。比如，编译 foo.o 失败了，make 可以继续尝试编译其它 对象文件。</p><p>默认行为下，是假设用户为了构建最终的程序，出现错误表明最终无法构建程序，所以 make 立即停止构建过程并报告错误信息。而指定 -k --keep-going 选项，则表示最终目的是为了 尽可能多的检查最近更改的程序存在的问题，此时，make 不会遇错立即终止。</p><p>如果执行某个 recipe 时终止了（因为失败或者因为终止信号），这个 recipe 生成的文件 是损坏的，而它个更新时间又是新的，下次执行的时候，make 会认为这个 target 不需要更新， 这是有问题的，正确的做法是，在出错终止时，如果这个 target 文件已经发生了变化就删除它。 由于历史原因，make 默认不会主动删除这些错误的文件。设置 <code>.DELETE_ON_ERROR:</code>就可以。</p><p>Q. 我在前面的文档里好像看到，会自动删除啊，什么条件来着？</p><h2 id="_5-6-终止-make" tabindex="-1"><a class="header-anchor" href="#_5-6-终止-make" aria-hidden="true">#</a> 5.6 终止 make</h2><p>Interrupting or Killing make</p><p>如前所述，make 遇错终止的时候可能会删除没有正确更新的 target 文件，make 依赖 target 文件的最后更新时间做这个判断。</p><p>编译器编译某个 .o 文件的时候，编译到一半，Ctr-C 杀死了编译进程，同时 make 也会捕获 Ctr-C 信号，删除不完整的文件。</p><p>可以关闭这个操作，把这个 target 文件作为特殊目标<code>.PRECIOUS:</code>的依赖即可。 这样做的原因可能有，这个 target 文件的更新是原子的，或者 target 文件只是为了记录 最后修改时间，或者target文件必须存在，否则会导致错误。</p><p>尽管 make 努力清理这些不完整的文件，但也不是万无一失的。比如，make 可能被无法捕获的 信号杀死，make 本身有bug，等等。</p><p>所以，最好是编写 recipe 的时候考虑到这个问题，使得 recipe 异常终止的时候也不会留下 不完整的文件。比如，使用临时文件，等生成完毕再重命名过去。一些编译器就是这么做的， 所以可以放心大胆的用。</p><h2 id="_5-7-递归调用-make" tabindex="-1"><a class="header-anchor" href="#_5-7-递归调用-make" aria-hidden="true">#</a> 5.7 递归调用 make</h2><p>在 recipe 中调用 make 命令，就是递归调用。 多个子系统组合成一个大系统的时候，每个自系统都有自己的makefile，还有一个总的makefile， 这种情况就适合使用递归调用。</p><p>例如，假设项目根目录下有个子目录 sub，它有自己的makefile，而你希望在顶级makefile中调用 它，代码就可以这么写：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">subsystem</span><span class="token punctuation">:</span>
    cd sub &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>或者等价的：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">subsystem</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -c sub
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以简单地复制使用这个代码。然而最好了解其中的细节和原因，了解顶层make和子make之间的 关系。</p><p>为了方便，GNU make 工具会设置一个变量 CURDIR，它对应 make 的工作目录（处理完 -C 选项之后）。 包含其它目录下的makefile，CURDIR 的值不会变。它不会被环境变量中设置 CURDIR 覆盖。 在 makefile 中手动设置这个变量的值，也不会对make产生影响，比如make不会因此更改当前的 工作目录。</p><h3 id="_5-7-1-make变量的工作方式" tabindex="-1"><a class="header-anchor" href="#_5-7-1-make变量的工作方式" aria-hidden="true">#</a> 5.7.1 MAKE变量的工作方式</h3><p>递归调用 make 时，应当总是使用变量 MAKE，不要直接使用 make 命令。</p><p>第一，变量 MAKE 总是指向当前 make 程序，如果使用了特定版本的make，这个变量也会扩展为 它，保证一致性。</p><p>第二，直接使用变量 MAKE 的 recipe 行，可以避开 -n、-t、-q 这三个选项的影响。 要求必须是直接使用 MAKE 变量，通过其它变量展开得到 MAKE 不具备这个效果。+ 和 直接使用 MAKE 变量有相同的效果。</p><p>ps：这一段解释这一特殊行为的原因。 接着用上面的例子，假设执行 make -t，对于 subsystem，make 会用 touch 命令创建文件 subsystem， 而你实际期望的行为是执行 cd sub &amp;&amp; make -t，但这要求执行 subsystem 的 recipe。</p><p>第三，直接使用了 $(MAKE) 的 recipe 行，当执行 -n、-t、-q 三个选项的时候，会得到执行， 同时通过常规的 MAKEFLAGS 变量把这个对应的选项传递进去，从而这三个选项会正确传播到 subsystem 中。</p><p>Q. 虽然不重要，但我想知道，在makefile中手动对MAKE变量赋值，会有影响吗？ Q. 再有，类似 MAKE 这样自动出现的变量还有哪些？</p><h3 id="_5-7-2-向子-make-传递变量" tabindex="-1"><a class="header-anchor" href="#_5-7-2-向子-make-传递变量" aria-hidden="true">#</a> 5.7.2 向子 make 传递变量</h3><p>递归调用make时，使用相关语句，可以把当前的make变量传递给子make，这些传递进去的变量 在子make中作为默认值存在，传递进去的变量不会覆盖子make中定义的同名变量，除非使用 -e 选项。</p><p>对于要导出/向下传递的变量，make 在启动执行 recipe 行的进程的时候，把这些变量添加到 子进程的的环境变量列表中，子 make 自动从环境变量中读取这些变量。</p><p>默认，make 只导出这样的变量：本就是来自环境变量或者用 -e 选项定义的变量，且变量名称 只包含数字字母下划线，因为有些shell只识别数字字母下划线构成的环境变量名。</p><p>make 变量 SHELL 不会传递给子 sub-make，而是把调用者环境变量的SHELL变量传递给sub-make。 如果非要把make变量SHELL传递过去，需要使用 export 指令（见下文）。 PS：sub-make同样不会以环境SHELL变量作为执行recipe的shell，而是用make变量SHELL。</p><p>make 变量 MAKEFLAGS 总是会导出，除非用 unexport 指令强制取消。 make 变量 MAKEFILES，如果设置了就导出，否则不导出。</p><p>Q. 变量 MAKEFLAGS 其默认值是什么？ Q. 环境变量，makefile中的变量，makefile中的 recipe 执行时的环境变量，相互关系是？ Q. 除了导出给 sub-make 的，导出给执行 recipe line 的shell进程的环境变量，是一样的机制吗？ Q. 这个导出，对于非sub-make的recipe line 也是如此吗？</p><p>make 自动创建的默认变量一般不会导出，sub-make 会自动创建自己的默认变量。 参见[Variables Used by Implicit Rules][5:v]</p><p>要导出变量到 sub-make，使用 export 指令，要禁止导出变量到 sub-make，使用 unexport 指令。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">export</span> variables...
<span class="token keyword">unexport</span> variables...
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>指令中的variables列表支持展开，所以可以用变量、函数，只要它们的展开结果是变量列表。</p><p>为了方便，可以把定义+导出合并为一条指令</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">export</span> variable<span class="token operator">=</span>value
<span class="token comment"># 等价于</span>
variable<span class="token operator">=</span>value
<span class="token keyword">export</span> variable
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>类似的还有</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">export</span> variable<span class="token operator">:=</span>value

variable<span class="token operator">:=</span>value
<span class="token keyword">export</span> variable

<span class="token keyword">export</span> variable<span class="token operator">+=</span>value

variable<span class="token operator">+=</span>value
<span class="token keyword">export</span> variable
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Q. =, :=, +=，还有什么 = 组合？</p><p>可以看到 make 中的 export/unexport 指令，和 shell、sh 中的语法、语义一致。</p><p>单独的export指令，作用是让make默认导出所有变量。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">export</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但用 unexport 指令明确禁止的除外。变量名中含有数字字母下划线之外的字符的也除外，除非 用 export 特意指定。</p><p>单独的 export 指令特性是为了兼容旧版 GNU Make，如果有些现存makefile依赖此特性，同时 又要兼容旧版make工具，可以定义 target <code>.EXPORT_ALL_VARIABLES:</code>，代替单独的export 指令， 旧版make会忽略 <code>.EXPORT_ALL_VARIABLES:</code>，但遇到单独的export指令会报错。</p><p>同理，可以用单独的 unexport 指令要求make默认不导出make变量。这本就是默认行为，但可以 用来覆盖前面的单独 export 指令的效果（比如include引入的makefile）。同时有多个独立 export和unexport指令时，最后的那个生效。</p><p>作为特例，变量 MAKELEVEL 每进入一层嵌套的sub-make，其值递增1，顶级make中此变量的值是0。 make在为recipe设置环境的时候对此变量值加一。</p><p>这个变量主要用于在条件指令中测试，以便于区分递归方式还是直接调用的makefile。</p><p>附个demo测试一下，如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">cat</span> Makefile
<span class="token comment"># MAKELEVEL的值</span>
<span class="token variable"><span class="token variable">$(</span>info MAKELEVEL:$<span class="token punctuation">{</span>MAKELEVEL<span class="token punctuation">}</span><span class="token variable">)</span></span>
ml:<span class="token punctuation">;</span> @echo <span class="token variable">${MAKELEVEL}</span>,$<span class="token variable">${MAKELEVEL}</span>

$ <span class="token function">make</span> ml
/bin/sh
MAKELEVEL:0
<span class="token number">0,1</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这表明，顶层make中，makefile里此变量的值是0，顶层make中，recipe 的shell进程，此变量的值是1。</p><p>MAKEFILES 变量会自动层层向内传递，所以可以通过设置此变量（环境变量或make变量）让所有 sub-make 载入共同的 makefile。</p><p>[5:v]: https://www.gnu.org/software/make/manual/make.html#Implicit-Variables Variables Used by Implicit Rules</p><h3 id="_5-7-3-向子-make-传递选项" tabindex="-1"><a class="header-anchor" href="#_5-7-3-向子-make-传递选项" aria-hidden="true">#</a> 5.7.3 向子 make 传递选项</h3><p>总结:</p><ul><li>基于变量导出机制，借助变量 MAKEFLAGS 传递选项 <ul><li>上层make自动设置命令行选项到 MAKEFLAGS 中，sub-make 自动读取此变量中的选项，并与直接在命令行中指定的选项同等对待</li><li>命令手动指定的变量定义也是通过这个变量传递到 sub-make 中</li></ul></li><li>有些选项不予传递：-C -f -O -W；同样，sub-make 会忽略这四个选项，双重保障</li><li>-j 选项控制并发作业的数量，对它做特殊处理，确保make和所有sub-make总的并发作业数量不超过 -j 指定的值</li><li>附：手动清空 MAKEFLAGS 可以禁止选项传递，清空 MAKEOVERRIDES 可以禁止命令行变量定义传递，同时保留选项继续传递</li><li>可以手动设置环境变量 MAKEFLAGS 或者在makefile中手动设置MAKEFLAGS变量，其指定的选项会附加到当前make进程的命令行选项列表中 Q. 像 MAKEFLAGS 这些变量都是正常的变量名，为什么 .SHELLFLAGS 却以句点开头？这样以句点开头的特殊地位的变量还有多少？</li></ul><p>诸如 -k、-s 之类的选项会通过变量 MAKEFLAGS 传递给 sub-make。make 会自动把接收到的命令行 选项设置到变量 MAKEFLAGS 中，例如设 make -ks，则 MAKEFLAGS 会有值 ks。</p><p>每个 sub-make 都有环境变量 MAKEFLAGS，sub-make 会查看此环境变量的值，分析其代表的 命令行参数，通过此变量指定命令行选项与直接在命令行中指定的选项具备同等效果。</p><p>于此相同，命令行中的变量定义也会通过 MAKEFLAGS 变量传递给 sub-make，sub-make 会把此 变量中包含等号（=）的项解读为变量定义，和在命令行中定义变量效果等同。</p><p>Q. 在shell中定义环境变量 MAKEFLAGS，对顶层make有效吗？ Ans：有</p><hr><p>make 不会把选项 -C -f -O -W 设置到变量 MAKEFLAGS 中，也就不会传递 sub-make。</p><p>PS：试验了一下，手动把 -C 追加到 MAKEFLAGS 中，子 make 也会忽略他。 PS：假设 MAKEFLAGS 变量不是给我们手动调用的，而仅是 make 和 sub-make 之间传递选项的 媒介，make 内部用的，那么： -f 指定 makefile 的路径，而一般递归make调用会指定自己 的makefile，所以不继承 -f 选项合理。</p><p>-j 选项也特殊，如果 -j 后面明确指定了正整数 N，那么 make 和所有 sub-make 之间会互相 协调，确保所有 make 进程总共只有 N 个作业同时运行。注意，make （和sub-make）进程自身不算作业， make 进程开启的执行作业（recipe）的子进程才算作业。</p><p>如果操作系统不支持上述协商，make 就不会把 -j 选项设置到 MAKEFLAGS 中，从而 sub-make 会顺序执行作业，如果把 -j 传递进入，每个 sub-make 都会有 N 个并发作业，最后并发作业 的总数就会远超 N 个（所以此时不传递 -j 选项是合理的）。如果 -j 后面面没有给定数字， 那么表示不限制并发数量，此时 make 会把 -j 通过 MAKEFLAGS 传递给 sub-make 进程。</p><p>如果要禁止向 sub-make 传递选项，可以手动清空 MAKEFLAGS 变量。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">subsystem</span><span class="token punctuation">:</span>
    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> MAKEFLAGS<span class="token operator">=</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>命令行中的变量定义实际在记录在变量 MAKEOVERRIDES 中，而 MAKEFLAGS 引用了这个变量， 所以如果希望只向下传递选项，同时禁止传递变量定义，可以清空 MAKEOVERRIDES 变量。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>MAKEOVERRIDES<span class="token operator">=</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>当然这么做一般没有什么意义。有些系统对命令行长度有限制，在这些系统上可以通过这中方法 缩短命令行长度。POSX 模式下（定义伪目标 <code>.POSIX:</code>），MAKEFLAGS 变量是不受 MAKEOVERRIDES 的影响的。</p><p>MAKEFLAGS 的前身是 MFLAGS，旧版本的make使用的是 MFLAGS，并且一般这么用</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">subsystem</span><span class="token punctuation">:</span>
    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MFLAGS<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为保持兼容性，当前的 make 版本，也支持 MFLAGS 变量，它的值和 MAKEFLAGS 完全相同。 如果希望 makefile 兼容旧版make，就可以用这个技术，这种方式，在新版make中完全可以 正常运行。</p><p>PS：新版 make 自动设置、自动读取 MAKEFLAGS 变量，更省事。</p><p>如果某些选项需要每次调用 make 命令的时候都指定，比如 -k，可以设置环境变量 MAKEFLAGS 或者直接在 makefile 中设置这个变量，这两处设置的选项都会附加到当前make命令的选项列表中。 手动设置 MFLAGS 不起作用，此变量仅是为了兼容旧版 make，可读，但写入不生效。</p><p>PS：如果设置了 make 变量MAKEFLAGS，当前make就不会根据最终命令行选项反过来更新当前的MAKEFLAGS变了； 如果没有设置，就会反过来更新一波。</p><ul><li>Q. (0001)手动指定的 MAKEFLAGS 变量中的选项是作为附加项还是覆盖其值呢？ Ans：作为附加选项。</li><li>Q. 如果在sub-make对应的makefile中设置MAKEFLAGS变量，会不会屏蔽掉上层make通过 MAKEFLAGS传递进来的选项？或者说，make 向sub-make传递选项，是通过MAKEFLAGS环境变量 还是通过make变量MAKEFLAGS？</li></ul><h3 id="_5-7-4-print-directory-选项" tabindex="-1"><a class="header-anchor" href="#_5-7-4-print-directory-选项" aria-hidden="true">#</a> 5.7.4 --print-directory 选项</h3><p>默认不打印。使用 -C 选项时，递归调用时默认打印。使用 -w --print-directory 时打印； 使用 --no-print-directory 禁止打印。</p><h2 id="_5-8-定义容器-recipe" tabindex="-1"><a class="header-anchor" href="#_5-8-定义容器-recipe" aria-hidden="true">#</a> 5.8 定义容器 recipe</h2><p>如果多次用到同一个命令序列，可以用容器 recipe。 容器 recipe 实际上是变量。</p><ul><li>递归展开</li><li>容器 recipe 内部可以自主使用特殊字符(@+0)；引用的时候整体加一个特殊字符，对容器内所有行有效。</li></ul><h2 id="_5-9-使用空-recipe" tabindex="-1"><a class="header-anchor" href="#_5-9-使用空-recipe" aria-hidden="true">#</a> 5.9 使用空 recipe</h2><h1 id="_6-变量" tabindex="-1"><a class="header-anchor" href="#_6-变量" aria-hidden="true">#</a> 6 变量</h1><p>引用变量的语法 $(var) 或者 ${var} 都行。 函数调用，$(fun args...) 或者 ${fun args..} 也都行。</p><h1 id="_9-how-to-run-make" tabindex="-1"><a class="header-anchor" href="#_9-how-to-run-make" aria-hidden="true">#</a> 9. How to Run Make</h1><p>2021-12-21 make 命令的常用选项。</p><p>同一个 makefile，搭配不同的 make 命令选项玩出不同的效果来。</p><ul><li>最常用的是更新所有过时的文件</li><li>只更新特定的文件</li><li>使用不同的编译器，使用不同的编译选项</li></ul><h2 id="_9-1-指定-makefile" tabindex="-1"><a class="header-anchor" href="#_9-1-指定-makefile" aria-hidden="true">#</a> 9.1 指定 makefile</h2><p>make 命令默认使用 <code>Makefile</code> 作为数据库文件名，可以用 -f 指定自定义的 makefile 文件。 可以多次指定 -f 选项，指定的多个 makefile 会按照顺序合并。</p><h2 id="_9-2-指定-goal" tabindex="-1"><a class="header-anchor" href="#_9-2-指定-goal" aria-hidden="true">#</a> 9.2 指定 goal</h2><blockquote><p>The goals are the targets that make should strive ultimately to update. Other targets are updated as well if they appear as prerequisites of goals, or prerequisites of prerequisites of goals, etc.</p></blockquote><ul><li>make 命令默认取 Makefile 的第一个 target（不算以句点开头的目标）作为 goal。</li><li>第一条规则有多个 target 时，只取第一个 target，而不是整个列表作为默认 goal</li><li>可以用 .DEFAULT_GOAL 变量设置默认 goal。 ps：一般没必要吧。 Q. 要是第一条规则的target包含通配符呢？ Ans：展开后按多个 target 处理。</li></ul><p>为构建不同的goal，直接把它作为 make 命令的位置参数传入即可。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span> main
<span class="token function">make</span> build
<span class="token function">make</span> run
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>makefile 文件中的任何 target 都可以作为 goal 指定给 make 命令。 但以 - 或 = 开头的 target 不行，因为 - 解释为选项，= 解释为变量定义。 没有在 makefile 列出的 target 也可以用，只要它们能从隐式规则中推导出来。</p><p>可以一次指定多个 goal，make 按照顺序构建它们。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span> clean build <span class="token builtin class-name">test</span> <span class="token function">install</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在命令行指定的 goal 列表可以用 MAKECMDGOALS 变量读取，如果命令行未指定，则此变量为空。 这个变量很少用到。一个应用场景是执行 clean 规则时避开包含 .d 文件。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>sources <span class="token operator">=</span> foo.c bar.c

<span class="token keyword">ifneq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKECMDGOALS<span class="token punctuation">)</span>,clean<span class="token punctuation">)</span>
<span class="token symbol">include <span class="token variable">$</span>(sources</span><span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">)</span>
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_9-3-instead-of-executing-recipes" tabindex="-1"><a class="header-anchor" href="#_9-3-instead-of-executing-recipes" aria-hidden="true">#</a> 9.3 Instead of Executing Recipes</h2><ul><li><p><code>-n --dry-run</code> 输出需要执行的 recipe，不实际执行。 ps：有些 recipe 仍会执行：1. MAKE 变量，2. include 指令</p></li><li><p><code>-t --touch</code> 只更新目标文件的时间戳，不真的执行 recipe</p></li><li><p><code>-q --question</code> 检查是否存在需要更新的 target，不执行 recipe。用退出码表示是否需要更新。 有需要更新的，退出码为 1.</p></li><li><p><code>-W file</code> <code>--what-if=file</code> <code>--assume-new=file</code> <code>--new-file=file</code> make 会当前时间作为 file 的修改时间（而不是file的实际修改时间）。 与 -n 选项搭配，可以分析某个文件更新后，哪些 target 受影响。</p></li></ul><p>同时使用上述选项中的三个会报错。</p><p>即使指定了 -n、-t、-q 选项，以 + 开头或者包含 $(MAKE) 或 ${MAKE} 的recipe中的行仍会执行， 注意，仅仅是以 + 开头或者包含 $(MAKE) 或 ${MAKE} 那些行会执行，同一个规则中的其它行不会执行。</p><h2 id="_9-4-跳过编译某些文件" tabindex="-1"><a class="header-anchor" href="#_9-4-跳过编译某些文件" aria-hidden="true">#</a> 9.4 跳过编译某些文件</h2><p>有些时候，修改了一个文件，make 认为有其它文件需要修改，而实际上不用修改，同时又不希望浪费时间 编译它，可以跳过编译这些文件。</p><p>官方手册给了例子和步骤……。</p><h2 id="_9-5-覆盖变量" tabindex="-1"><a class="header-anchor" href="#_9-5-覆盖变量" aria-hidden="true">#</a> 9.5 覆盖变量</h2><p>可以在命令行覆盖 makefile 中的变量，形式是 <code>var=val</code>，makefile中所有对 var 变量的赋值语句都会被忽略，并 称“命令行参数覆盖了makefile中的变量”。</p><p>最常见的用途是为 C 编译器指定额外的编译选项。如：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>CFLAGS<span class="token operator">=</span>-g

<span class="token symbol">foo</span><span class="token punctuation">:</span> foo.c
    cc -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c -o foo
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>make CFLAGS=&#39;-g -O&#39; foo</code>.</p><p>命令行，这种形式定义的变量 <code>val=val</code> 是递归展开的，若要定义简单展开的变量，使用 := 或 ::= 代替 =。 除非在 val 中引用其它变量或者函数调用，否则简单展开和递归展开是没有区别的。</p><p>makefile中的 override 指令可以反过来覆盖命令行中定义的变量。 <code>override variable = value</code>.</p><h2 id="_9-6-测试编译过程" tabindex="-1"><a class="header-anchor" href="#_9-6-测试编译过程" aria-hidden="true">#</a> 9.6 测试编译过程</h2><p>当执行 recipe 出错时，make 立即报错退出。 但如果你刚刚修改了一个文件，希望make继续编译，以尽可能多地发现存在的问题，这时候 可以用 -k --keep-going 选项。</p><blockquote><p>On these occasions, you should use the ‘-k’ or ‘--keep-going’ flag. This tells make to continue to consider the other prerequisites of the pending targets, remaking them if necessary, before it gives up and returns nonzero status. For example, after an error in compiling one object file, ‘make -k’ will continue compiling other object files even though it already knows that linking them will be impossible.</p></blockquote><p>通常，调用 make 的目的是构造 goal，make 以此为前提，遇到错误立即报错退出是正确的。 -k 选项则告诉 make，真正的目的是为了尽可能多地检测代码错误，所以此时 make 会尽可能地 继续执行下去。</p><h2 id="_9-7-选项总结" tabindex="-1"><a class="header-anchor" href="#_9-7-选项总结" aria-hidden="true">#</a> 9.7 选项总结</h2><p>make 命令的剩余选项在这一章节列出。</p><ul><li><p><code>-j [N] --jobs[=N]</code> 指定并发运行的 recipe 数量。省略数字，则能并行多少就并行多少。</p></li><li><p><code>-O[type] --output-sync[=type]</code> 确保每个 recipe 的输出不被其它输出打乱。此选项仅和 --jobs 选项搭配时才有必要。 type 的可取值有 line、target、recurse、none。target 是缺省值，表示一个 recipe 内的所有输出保持一组。</p></li><li><p><code>-l [load] --load-average[=load] --max-load[=load]</code> 当已经有其它 recipe 运行且系统负载大于等于 load 时，不在运行新的 recipe。与 --jobs 搭配。 省略 load，表示不限制。load 是一个浮点数。</p></li><li><p><code>-r --no-builtin-rules</code> 忽略内置隐式规则</p></li><li><p><code>-R --no-builtin-variables</code> 忽略特定于内置隐式规则的变量，此选项隐含 -r 选项</p></li><li><p><code>-B --always-make</code> 忽略新旧关系，无条件重新构建所有相关 target</p></li><li><p><code>-C dir</code> 切换到 dir 目录下再读取 makefile。<code>make -C foo -C bar</code> 效果类似于 <code>cd foo &amp;&amp; cd bar &amp;&amp; make</code></p></li><li><p><code>-d</code> 等价于 --debug=a，输出调试信息。包括：要检查哪个文件、检查结果是什么、哪个文件最终要 remade，尝试了哪个隐式规则，最终哪个隐式规则用上了，等等。</p><blockquote><p>Print debugging information in addition to normal processing. The debugging information says which files are being considered for remaking, which file-times are being compared and with what results, which files actually need to be remade, which implicit rules are considered and which are applied—everything interesting about how make decides what to do. The -d option is equivalent to ‘--debug=a’</p></blockquote></li><li><p><code>--debug</code> 输出指定级别的调试信息。指定的值只考虑第一个字符，且要用逗号或空白分隔</p><ul><li>a(all) 所有调试信息。等价于 -d</li><li>b(basic) 指定 --debug 时的默认选项。基础debug信息包括：哪个target过期了，构建结果是成功还是失败。</li><li>v(verbose) 在 basic 的基础上，输出如下信息：读取了哪个makefile，哪个 prerequisite 不需要重建（rebuild），等。</li><li>i(implicit) 在 basic 的基础上，输出隐式规则的搜索过程</li><li>j(jobs) 输出 sub-commands 的调用细节。ps：不是在basic的基础上；Q. sub-command 莫非是指递归 make 调用?</li><li>m(makefile) 在 basic 的基础上，输出 remake makefile 的信息；注意，all 选项不包括这一个信息</li><li>n(none) 关闭到当前位置的调试信息，后续再有调试信息选项，那些选项会生效</li></ul></li></ul><h1 id="_10-using-implicit-rules" tabindex="-1"><a class="header-anchor" href="#_10-using-implicit-rules" aria-hidden="true">#</a> 10 Using Implicit Rules</h1><p>有些构建规则使用频率很高，比如用 cc 把 .c 编译成 .o。 根据文件名选择对应的隐式规则。 隐式规则可以按顺序链式调用，比如 .y -&gt; .c -&gt; .o 文件。</p><p>内置的隐式规则，其recipe使用一些变量，如此便可通过设置变量的值定制隐式规则的工作方式。 比如，在编译C程序的时候，CLFAGS 可隐式规则传递给C编译器的 flags 参数。</p><p>还可以通过模式规则(pattern rules)自定义隐式规则。</p><p>后缀规则是一种更受限的隐式规则定义方法，仅为了后向兼容性。 Suffix rules are a more limited way to define implicit rules. Pattern rules are more general and clearer, but suffix rules are retained for compatibility.</p><ul><li>• Using Implicit How to use an existing implicit rule to get the recipes for updating a file.</li><li>• Catalogue of Rules A list of built-in rules.</li><li>• Implicit Variables How to change what predefined rules do.</li><li>• Chained Rules How to use a chain of implicit rules.</li><li>• Pattern Rules How to define new implicit rules.</li><li>• Last Resort How to define a recipe for rules which cannot find any.</li><li>• Suffix Rules The old-fashioned style of implicit rule.</li><li>• Implicit Rule Search The precise algorithm for applying implicit rules.</li></ul><h2 id="_10-1-using-implicit-rules" tabindex="-1"><a class="header-anchor" href="#_10-1-using-implicit-rules" aria-hidden="true">#</a> 10.1 Using Implicit Rules</h2><p>只要不指定recipe，make命令就会尝试查找适当的隐式规则。 make 根据现存的或者可以生成的源文件的类型确定要使用哪条隐式规则。 To allow make to find a customary method for updating a target file, all you have to do is refrain from specifying recipes yourself. Either write a rule with no recipe, or don’t write a rule at all. Then make will figure out which implicit rule to use based on which kind of source file exists or can be made.</p><p>假设有如下makefile，你在规则中提到了 foo.o 但是没有给出以 foo.o 为目标的规则，那么 make 就会查找合适的隐式规则生成foo.o，无论foo.o是否已经存在。 如果找到了匹配的隐式规则，此规则可以同时提供一个recipe和一个或以上的前置条件。 如果需要指定额外的依赖（比如头文件），你可以写一条不带有 recipe的 以 foo.o 为目标的规则。 For example, suppose the makefile looks like this:</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>foo : foo.o bar.o
        cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Because you mention foo.o but do not give a rule for it, make will automatically look for an implicit rule that tells how to update it. This happens whether or not the file foo.o currently exists.</p><p>If an implicit rule is found, it can supply both a recipe and one or more prerequisites (the source files). You would want to write a rule for foo.o with no recipe if you need to specify additional prerequisites, such as header files, that the implicit rule cannot supply.</p><p>每个隐式规则都有一个目标模式和前置条件模式。可以同时存在多个目标模式相同的隐式规则， 只要他们的前置条件不同，这时，哪个隐式规则的前置条件存在或者可以生成，make就选择哪条 隐式规则。 Each implicit rule has a target pattern and prerequisite patterns. There may be many implicit rules with the same target pattern. For example, numerous rules make ‘.o’ files: one, from a ‘.c’ file with the C compiler; another, from a ‘.p’ file with the Pascal compiler; and so on. The rule that actually applies is the one whose prerequisites exist or can be made. So, if you have a file foo.c, make will run the C compiler; otherwise, if you have a file foo.p, make will run the Pascal compiler; and so on.</p><p>自然，当你编写makefile的时候，你知道自己希望哪条规则生效，你知道make会选择这条规则， 因为你知道这条规则的前置条件预期会存在。 Of course, when you write the makefile, you know which implicit rule you want make to use, and you know it will choose that one because you know which possible prerequisite files are supposed to exist. See Catalogue of Built-In Rules, for a catalogue of all the predefined implicit rules.</p><p>我们说某依赖“存在或可以生成”，文件“可以生成”的含义是，该文件是某条显式规则的target或 依赖，或者可以找到某条能生成此文件的隐式规则。 当某条隐式规则的依赖是另一个隐式规则的target时，称出现了链式规则。 Above, we said an implicit rule applies if the required prerequisites “exist or can be made”. A file “can be made” if it is mentioned explicitly in the makefile as a target or a prerequisite, or if an implicit rule can be recursively found for how to make it. When an implicit prerequisite is the result of another implicit rule, we say that chaining is occurring. See Chains of Implicit Rules.</p><p>make 会为每个未指定recipe的target以及未指定recipe的双冒号规则搜索隐式条件。 仅作为依赖出现的文件会被视作一条无任何内容的规则的target，所以makek也会为这类文件搜索 隐式规则。 ps：合起来就是，make会为每个无 recipe的target（包括仅作为依赖出现的文件）搜索隐式规则。</p><p>In general, make searches for an implicit rule for each target, and for each double-colon rule, that has no recipe. A file that is mentioned only as a prerequisite is considered a target whose rule specifies nothing, so implicit rule search happens for it. See Implicit Rule Search Algorithm, for the details of how the search is done.</p><p>隐式规则的选择不受显式依赖的影响，比如如下makefile中，如果同时存在 foo.c 和 foo.p,则 仍旧优先使用 foo.c 生成 foo.o,因为使用 C 的隐式规则在使用 Pascal 的隐式规则的顺序更 靠前。 Note that explicit prerequisites do not influence implicit rule search. For example, consider this explicit rule:</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>foo.o: foo.p
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>The prerequisite on foo.p does not necessarily mean that make will remake foo.o according to the implicit rule to make an object file, a .o file, from a Pascal source file, a .p file. For example, if foo.c also exists, the implicit rule to make an object file from a C source file is used instead, because it appears before the Pascal rule in the list of predefined implicit rules (see Catalogue of Built-In Rules).</p><p>对于没有 recipe 的 target 使用隐式规则，可以写一条规则，为该target提供一个空recipe。 ps:空recipe就是只有一个分号的recipe，如：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">foo</span><span class="token punctuation">:</span>
    <span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>If you do not want an implicit rule to be used for a target that has no recipe, you can give that target an empty recipe by writing a semicolon (see Defining Empty Recipes).</p><h2 id="_10-2-catalogue-of-built-in-rules" tabindex="-1"><a class="header-anchor" href="#_10-2-catalogue-of-built-in-rules" aria-hidden="true">#</a> 10.2 Catalogue of Built-In Rules</h2><p>内置隐式规则总是有的，除非明确覆盖或者取消他们。 （-r --no-builtin-rules取消所有内置规则）。 ps：内置规则，都是隐式规则。</p><p>不同平台、不同版本的make，其内置的隐式规则不完全一致，在一个不包含makefile的目录下执行 <code>make -p</code>命令，可以查看当前make工具实际的内置规则和变量。 本手册列出的内置规则在基于 POSIX 的系统上可用。</p><p>即使不指定 -r 选项，也不是所有的内置规则都总是可用的。 在make内部，这里的隐式规则，有不少是通过 suffix rule 实现的，所以它们到时候是否生效， 还要受到 suffix list 的影响，可以通过 .SUFFIXES 这个特殊的target控制 suffix list。 ps：suffix rule 是旧风格，它的继任者就是更强健的模式规则（pattern rule）。</p><ul><li><p>编译C程序： %.o: %.c $(CC) $(CPPFLAGS) $(CFLAGS) -c</p></li><li><p>编译C++程序： %.o: %.cc %.cpp %.C $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c</p></li><li><p>编译 Pascal</p></li><li><p>编译 Fortran</p></li><li><p>预处理Fortran</p></li><li><p>编译 Modula-2</p></li><li><p>汇编和预处理汇编程序 %.o:%.s $(AS) $(ASFLAGS) %.s:%.S $(CPP) $(CPPFLAGS)</p></li><li><p>链接单个对象文件 %: %.o $(CC) $(LDFLAGS) %.o $(LOADLIBS) $(LDLIBS)</p><p>这条规则对于简单情况有效，复杂的情况就要手动编写链接规则。</p></li><li><p>针对C程序的yacc %.c: %.y $(YACC) $(YFLAGS) ...</p></li></ul><p>通常，你只需要修改上述隐式规则中使用的内置变量即可。</p><p>实际上，内置规则实际使用的变量类似于 COMPILE.c, LINK.c，它们保存了上述列出的recpie。 用于编译 .x 源文件的隐式规则使用变量 COMPILE.x，以及用于从 .x 生成可执行文件的内置规则 使用变量 LINK.x，预处理 .x 文件的内置规则使用变量 PREPROCESS.x。</p><p>关于生成 .o 文件的内置规则，和OUTPUT_OPTION，以及在某些系统上的tricky。 Every rule that produces an object file uses the variable OUTPUT_OPTION. make defines this variable either to contain ‘-o $@’, or to be empty, depending on a compile-time option. You need the ‘-o’ option to ensure that the output goes into the right file when the source file is in a different directory, as when using VPATH (see Directory Search). However, compilers on some systems do not accept a ‘-o’ switch for object files. If you use such a system, and use VPATH, some compilations will put their output in the wrong place. A possible workaround for this problem is to give OUTPUT_OPTION the value ‘; mv $*.o $@’.</p><h2 id="_10-3-variables-used-by-implicit-rules" tabindex="-1"><a class="header-anchor" href="#_10-3-variables-used-by-implicit-rules" aria-hidden="true">#</a> 10.3 Variables Used by Implicit Rules</h2><ol><li>内置规则使用了内置变量，可以在makefile中修改这些内置变量的值，从而定制内置规则的行为。</li><li>使用 -R --no-builtin-variables 选项取消所有内置变量的定义</li><li>内置规则使用的内置变量可以分成两类；一类指定编译工具，一类指定编译选项。</li><li>手册列出了最常用的内置变量。</li></ol><h2 id="_10-4-隐式规则的链式调用" tabindex="-1"><a class="header-anchor" href="#_10-4-隐式规则的链式调用" aria-hidden="true">#</a> 10.4 隐式规则的链式调用</h2><p>Chains of Implicit Rules</p><p>make足够聪明，能够判断出是否需要链式使用隐式规则。比如 .y -&gt; .c -&gt; .o。 Sometimes a file can be made by a sequence of implicit rules. For example, a file n.o could be made from n.y by running first Yacc and then cc. Such a sequence is called a chain.</p><p>If the file n.c exists, or is mentioned in the makefile, no special searching is required: make finds that the object file can be made by C compilation from n.c; later on, when considering how to make n.c, the rule for running Yacc is used. Ultimately both n.c and n.o are updated.</p><p>However, even if n.c does not exist and is not mentioned, make knows how to envision it as the missing link between n.o and n.y! In this case, n.c is called an intermediate file. Once make has decided to use the intermediate file, it is entered in the data base as if it had been mentioned in the makefile, along with the implicit rule that says how to create it.</p><p>Intermediate files are remade using their rules just like all other files. But intermediate files are treated differently in two ways.</p><p>链式使用隐式规则，提到“中间文件”，它有两个不同于普通文件的地方：</p><ol><li>对更新的影响</li><li>make 用后自动删除 The first difference is what happens if the intermediate file does not exist. If an ordinary file b does not exist, and make considers a target that depends on b, it invariably creates b and then updates the target from b. But if b is an intermediate file, then make can leave well enough alone. It won’t bother updating b, or the ultimate target, unless some prerequisite of b is newer than that target or there is some other reason to update that target.</li></ol><p>The second difference is that if make does create b in order to update something else, it deletes b later on after it is no longer needed. Therefore, an intermediate file which did not exist before make also does not exist after make. make reports the deletion to you by printing a ‘rm -f’ command showing which file it is deleting.</p><p>中间文件，显式规则的target或依赖不可作为中间文件。除非你要求make这么做。 Ordinarily, a file cannot be intermediate if it is mentioned in the makefile as a target or prerequisite. However, you can explicitly mark a file as intermediate by listing it as a prerequisite of the special target .INTERMEDIATE. This takes effect even if the file is mentioned explicitly in some other way. 你可以要求保留生成的中建文件。 You can prevent automatic deletion of an intermediate file by marking it as a secondary file. To do this, list it as a prerequisite of the special target .SECONDARY. When a file is secondary, make will not create the file merely because it does not already exist, but make does not automatically delete the file. Marking a file as secondary also marks it as intermediate.</p><p>You can list the target pattern of an implicit rule (such as ‘%.o’) as a prerequisite of the special target .PRECIOUS to preserve intermediate files made by implicit rules whose target patterns match that file’s name; see Interrupts.</p><p>隐式规则链可以包含两个以上的隐式规则。 A chain can involve more than two implicit rules. For example, it is possible to make a file foo from RCS/foo.y,v by running RCS, Yacc and cc. Then both foo.y and foo.c are intermediate files that are deleted at the end.</p><p>但一个链中，一个隐式规则至多出现一次，这是为了避开死循环。 No single implicit rule can appear more than once in a chain. This means that make will not even consider such a ridiculous thing as making foo from foo.o.o by running the linker twice. This constraint has the added benefit of preventing any infinite loop in the search for an implicit rule chain.</p><p>有些优化，比如从 foo.c 生成 foo 可以先生成 .o 再链接成 foo，也可以一步到位，为了效率， make 会选择一步到位，这种选择通过内置规则的顺序实现的。 There are some special implicit rules to optimize certain cases that would otherwise be handled by rule chains. For example, making foo from foo.c could be handled by compiling and linking with separate chained rules, using foo.o as an intermediate file. But what actually happens is that a special rule for this case does the compilation and linking with a single cc command. The optimized rule is used in preference to the step-by-step chain because it comes earlier in the ordering of rules.</p><p>考虑效率，搜索构建隐式规则的依赖时，不会考虑非尾节点的 &quot;%:&quot; 的隐式规则，因为 % 没有任何普通字符，它 匹配一切东西，匹配的太过宽泛了。 Finally, for performance reasons make will not consider non-terminal match-anything rules (i.e., ‘%:’) when searching for a rule to build a prerequisite of an implicit rule (see Match-Anything Rules).</p><h2 id="_10-5-自定义和重新定义模式规则" tabindex="-1"><a class="header-anchor" href="#_10-5-自定义和重新定义模式规则" aria-hidden="true">#</a> 10.5 自定义和重新定义模式规则</h2><p>Defining and Redefining Pattern Rules</p><ol><li>写一条模式规则，就实现了定义一条隐式规则。</li><li>隐式规则的target有且仅有一个 %, 它是个通配符，可以匹配任何非空字符串。% 匹配的子串 叫做枝干（stem）。</li><li>pattern 中的 % 的展开，是在变量替换和函数执行之后进行的。 You define an implicit rule by writing a pattern rule. A pattern rule looks like an ordinary rule, except that its target contains the character ‘%’ (exactly one of them). The target is considered a pattern for matching file names; the ‘%’ can match any nonempty substring, while other characters match only themselves. The prerequisites likewise use ‘%’ to show how their names relate to the target name.</li></ol><p>Thus, a pattern rule ‘%.o : %.c’ says how to make any file stem.o from another file stem.c.</p><p>Note that expansion using ‘%’ in pattern rules occurs after any variable or function expansions, which take place when the makefile is read. See How to Use Variables, and Functions for Transforming Text.</p><ul><li>• Pattern Intro An introduction to pattern rules.</li><li>• Pattern Examples Examples of pattern rules.</li><li>• Automatic Variables How to use automatic variables in the recipe of implicit rules.</li><li>• Pattern Match How patterns match.</li><li>• Match-Anything Rules Precautions you should take prior to defining rules that can match any target file whatever.</li><li>• Canceling Rules How to override or cancel built-in rules.</li></ul><h3 id="_10-5-1-introduction-to-pattern-rules" tabindex="-1"><a class="header-anchor" href="#_10-5-1-introduction-to-pattern-rules" aria-hidden="true">#</a> 10.5.1 Introduction to Pattern Rules</h3><p>A pattern rule contains the character ‘%’ (exactly one of them) in the target; otherwise, it looks exactly like an ordinary rule. The target is a pattern for matching file names; the ‘%’ matches any nonempty substring, while other characters match only themselves.</p><p>模式规则中，target中的 % 匹配到的字符串叫做枝干。 For example, ‘%.c’ as a pattern matches any file name that ends in ‘.c’. ‘s.%.c’ as a pattern matches any file name that starts with ‘s.’, ends in ‘.c’ and is at least five characters long. (There must be at least one character to match the ‘%’.) The substring that the ‘%’ matches is called the stem.</p><p>依赖中的 % 代表同样的枝干。 模式规则生效的前提是：该规则的target能匹配到某个文件，且规则的依赖（将%替换成对应的 子串之后）必须是已存在文件或是可以生成的文件。 ‘%’ in a prerequisite of a pattern rule stands for the same stem that was matched by the ‘%’ in the target. In order for the pattern rule to apply, its target pattern must match the file name under consideration and all of its prerequisites (after pattern substitution) must name files that exist or can be made. These files become prerequisites of the target.</p><p>Thus, a rule of the form</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token symbol">%.o</span> <span class="token punctuation">:</span> %.c <span class="token punctuation">;</span> recipe…
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>specifies how to make a file n.o, with another file n.c as its prerequisite, provided that n.c exists or can be made.</p><p>模式规则的依赖中可以不使用 %，少数情形下，需要用这种写法。 There may also be prerequisites that do not use ‘%’; such a prerequisite attaches to every file made by this pattern rule. These unvarying prerequisites are useful occasionally.</p><p>模式规则甚至可以不书写任何依赖，这时的模式规则其实就是一个万能统配规则，它匹配任何符合 target模式的文件。参考 Last Resort. A pattern rule need not have any prerequisites that contain ‘%’, or in fact any prerequisites at all. Such a rule is effectively a general wildcard. It provides a way to make any file that matches the target pattern. See Last Resort.</p><h3 id="_10-5-2-pattern-rule-examples" tabindex="-1"><a class="header-anchor" href="#_10-5-2-pattern-rule-examples" aria-hidden="true">#</a> 10.5.2 Pattern Rule Examples</h3><p>Here are some examples of pattern rules actually predefined in make. First, the rule that compiles ‘.c’ files into ‘.o’ files:</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>%.o : %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) <!--vuepress-ssr-app-->lt; -o $@
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>defines a rule that can make any file x.o from x.c. The recipe uses the automatic variables ‘$@’ and ‘<!--vuepress-ssr-app-->lt;’ to substitute the names of the target file and the source file in each case where the rule applies (see Automatic Variables).</p><p>Here is a second built-in rule:</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>% :: RCS/%,v
        $(CO) $(COFLAGS) <!--vuepress-ssr-app-->lt;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>defines a rule that can make any file x whatsoever from a corresponding file x,v in the sub-directory RCS. Since the target is ‘%’, this rule will apply to any file whatever, provided the appropriate prerequisite file exists. The double colon makes the rule terminal, which means that its prerequisite may not be an intermediate file (see Match-Anything Pattern Rules).</p><p>This pattern rule has two targets:</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>%.tab.c %.tab.h: %.y
        bison -d <!--vuepress-ssr-app-->lt;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>This tells make that the recipe ‘bison -d x.y’ will make both x.tab.c and x.tab.h. If the file foo depends on the files parse.tab.o and scan.o and the file scan.o depends on the file parse.tab.h, when parse.y is changed, the recipe ‘bison -d parse.y’ will be executed only once, and the prerequisites of both parse.tab.o and scan.o will be satisfied. (Presumably the file parse.tab.o will be recompiled from parse.tab.c and the file scan.o from scan.c, while foo is linked from parse.tab.o, scan.o, and its other prerequisites, and it will execute happily ever after.)</p><h3 id="_10-5-3-automatic-variables" tabindex="-1"><a class="header-anchor" href="#_10-5-3-automatic-variables" aria-hidden="true">#</a> 10.5.3 Automatic Variables</h3><p>为解决模式规则中的recipe中，指定动态文件名的问题，make 创建了动态变量。 动态变量仅限于recipe中有效，不要在target和prerequisite中使用（未定义， 会扩展为空串）。 Suppose you are writing a pattern rule to compile a ‘.c’ file into a ‘.o’ file: how do you write the ‘cc’ command so that it operates on the right source file name? You cannot write the name in the recipe, because the name is different each time the implicit rule is applied.</p><p>What you do is use a special feature of make, the automatic variables. These variables have values computed afresh for each rule that is executed, based on the target and prerequisites of the rule. In this example, you would use ‘$@’ for the object file name and ‘<!--vuepress-ssr-app-->lt;’ for the source file name.</p><p>It’s very important that you recognize the limited scope in which automatic variable values are available: they only have values within the recipe. In particular, you cannot use them anywhere within the target list of a rule; they have no value there and will expand to the empty string. Also, they cannot be accessed directly within the prerequisite list of a rule. A common mistake is attempting to use $@ within the prerequisites list; this will not work. However, there is a special feature of GNU make, secondary expansion (see Secondary Expansion), which will allow automatic variable values to be used in prerequisite lists.</p><p>自动变量清单，还是有几个的。选几个常用的。</p><ul><li><p>$@: target</p></li><li><p><!--vuepress-ssr-app-->lt;: first prerequisite</p></li><li><p>$^: all prerequisite</p></li><li><p>$%, %? $@</p><p>The file name of the target of the rule. If the target is an archive member, then ‘$@’ is the name of the archive file. In a pattern rule that has multiple targets (see Introduction to Pattern Rules), ‘$@’ is the name of whichever target caused the rule’s recipe to be run. $%</p><p>The target member name, when the target is an archive member. See Archives. For example, if the target is foo.a(bar.o) then ‘$%’ is bar.o and ‘$@’ is foo.a. ‘$%’ is empty when the target is not an archive member. <!--vuepress-ssr-app-->lt;</p><p>The name of the first prerequisite. If the target got its recipe from an implicit rule, this will be the first prerequisite added by the implicit rule (see Implicit Rules). $?</p><p>The names of all the prerequisites that are newer than the target, with spaces between them. If the target does not exist, all prerequisites will be included. For prerequisites which are archive members, only the named member is used (see Archives). $^</p><p>The names of all the prerequisites, with spaces between them. For prerequisites which are archive members, only the named member is used (see Archives). A target has only one prerequisite on each other file it depends on, no matter how many times each file is listed as a prerequisite. So if you list a prerequisite more than once for a target, the value of $^ contains just one copy of the name. This list does not contain any of the order-only prerequisites; for those see the ‘$|’ variable, below. $+</p><p>This is like ‘$^’, but prerequisites listed more than once are duplicated in the order they were listed in the makefile. This is primarily useful for use in linking commands where it is meaningful to repeat library file names in a particular order. $|</p><p>The names of all the order-only prerequisites, with spaces between them. $*</p><p>The stem with which an implicit rule matches (see How Patterns Match). If the target is dir/a.foo.b and the target pattern is a.%.b then the stem is dir/foo. The stem is useful for constructing names of related files.</p><p>In a static pattern rule, the stem is part of the file name that matched the ‘%’ in the target pattern.</p><p>In an explicit rule, there is no stem; so ‘$<em>’ cannot be determined in that way. Instead, if the target name ends with a recognized suffix (see Old-Fashioned Suffix Rules), ‘$</em>’ is set to the target name minus the suffix. For example, if the target name is ‘foo.c’, then ‘$<em>’ is set to ‘foo’, since ‘.c’ is a suffix. GNU make does this bizarre thing only for compatibility with other implementations of make. You should generally avoid using ‘$</em>’ except in implicit rules or static pattern rules.</p><p>If the target name in an explicit rule does not end with a recognized suffix, ‘$*’ is set to the empty string for that rule.</p></li></ul><p>‘$?’ is useful even in explicit rules when you wish to operate on only the prerequisites that have changed. For example, suppose that an archive named lib is supposed to contain copies of several object files. This rule copies just the changed object files into the archive:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>lib: foo.o bar.o lose.o win.o
        ar r lib $?
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Of the variables listed above, four have values that are single file names, and three have values that are lists of file names. These seven have variants that get just the file’s directory name or just the file name within the directory. The variant variables’ names are formed by appending ‘D’ or ‘F’, respectively. The functions dir and notdir can be used to obtain a similar effect (see Functions for File Names). Note, however, that the ‘D’ variants all omit the trailing slash which always appears in the output of the dir function. Here is a table of the variants:</p><p>‘$(@D)’</p><pre><code>The directory part of the file name of the target, with the trailing slash removed. If the value of ‘$@’ is dir/foo.o then ‘$(@D)’ is dir. This value is . if ‘$@’ does not contain a slash.
</code></pre><p>‘$(@F)’</p><pre><code>The file-within-directory part of the file name of the target. If the value of ‘$@’ is dir/foo.o then ‘$(@F)’ is foo.o. ‘$(@F)’ is equivalent to ‘$(notdir $@)’.
</code></pre><p>‘$(*D)’ ‘$(*F)’</p><pre><code>The directory part and the file-within-directory part of the stem; dir and foo in this example.
</code></pre><p>‘$(%D)’ ‘$(%F)’</p><pre><code>The directory part and the file-within-directory part of the target archive member name. This makes sense only for archive member targets of the form archive(member) and is useful only when member may contain a directory name. (See Archive Members as Targets.)
</code></pre><p>‘$(&lt;D)’ ‘$(&lt;F)’</p><pre><code>The directory part and the file-within-directory part of the first prerequisite.
</code></pre><p>‘$(^D)’ ‘$(^F)’</p><pre><code>Lists of the directory parts and the file-within-directory parts of all prerequisites.
</code></pre><p>‘$(+D)’ ‘$(+F)’</p><pre><code>Lists of the directory parts and the file-within-directory parts of all prerequisites, including multiple instances of duplicated prerequisites.
</code></pre><p>‘$(?D)’ ‘$(?F)’</p><pre><code>Lists of the directory parts and the file-within-directory parts of all prerequisites that are newer than the target.
</code></pre><p>Note that we use a special stylistic convention when we talk about these automatic variables; we write “the value of ‘<!--vuepress-ssr-app-->lt;’”, rather than “the variable &lt;” as we would write for ordinary variables such as objects and CFLAGS. We think this convention looks more natural in this special case. Please do not assume it has a deep significance; ‘<!--vuepress-ssr-app-->lt;’ refers to the variable named &lt; just as ‘$(CFLAGS)’ refers to the variable named CFLAGS. You could just as well use ‘$(&lt;)’ in place of ‘<!--vuepress-ssr-app-->lt;’.</p><h3 id="_10-5-4-how-patterns-match" tabindex="-1"><a class="header-anchor" href="#_10-5-4-how-patterns-match" aria-hidden="true">#</a> 10.5.4 How Patterns Match</h3><p>目标模式由一个%和可选的前后缀构成，一个模式可以匹配给定的文件名仅当该文件名以模式的前缀 开头，以模式的后缀结尾；匹配成功后，前后缀之间的部分叫做主干（stem）。比如 %.o 匹配 test.o 时，主干就是 test。然后规则的依赖中，%替换为主干，以获得实际的依赖。 比如 <code>%.o: %.c ;</code> 匹配 test.o 时，它的依赖就是 test.c。 A target pattern is composed of a ‘%’ between a prefix and a suffix, either or both of which may be empty. The pattern matches a file name only if the file name starts with the prefix and ends with the suffix, without overlap. The text between the prefix and the suffix is called the stem. Thus, when the pattern ‘%.o’ matches the file name test.o, the stem is ‘test’. The pattern rule prerequisites are turned into actual file names by substituting the stem for the character ‘%’. Thus, if in the same example one of the prerequisites is written as ‘%.c’, it expands to ‘test.c’.</p><p>目标模式一般不含斜杆，但同样可以匹配含义斜杠的路径名。</p><ul><li>匹配的时候只对文件的basename进行匹配，</li><li>替换依赖中的%的时候，目录会作为前缀，放在结果上。 Q. 目标模式含有斜杠呢？ <code>e%t: c%r</code> 匹配文件 src/eat，stem 是 src/a, 对 c%r 替换得到实际依赖是 src/car. 原文如下：</li></ul><blockquote><p>When the target pattern does not contain a slash (and it usually does not), directory names in the file names are removed from the file name before it is compared with the target prefix and suffix. After the comparison of the file name to the target pattern, the directory names, along with the slash that ends them, are added on to the prerequisite file names generated from the pattern rule’s prerequisite patterns and the file name. The directories are ignored only for the purpose of finding an implicit rule to use, not in the application of that rule. Thus, ‘e%t’ matches the file name src/eat, with ‘src/a’ as the stem. When prerequisites are turned into file names, the directories from the stem are added at the front, while the rest of the stem is substituted for the ‘%’. The stem ‘src/a’ with a prerequisite pattern ‘c%r’ gives the file name src/car.</p></blockquote><p>仅当匹配它时候，内置规则才会起效。 显式书写的规则优先于内置规则。 注意，如果一个规则 R 的依赖项实际存在，或者有显式描述，那么规则 R 的优先级高于必须借由 链式隐式规则才能生成依赖项的规则。</p><p>A pattern rule can be used to build a given file only if there is a target pattern that matches the file name, and all prerequisites in that rule either exist or can be built. The rules you write take precedence over those that are built in. Note however, that a rule whose prerequisites actually exist or are mentioned always takes priority over a rule with prerequisites that must be made by chaining other implicit rules.</p><p>Q. 不能白这个“Note however”这句话的意义？ 放在这一段中，好像是说有些情况下隐含规则会优先于明确写出的规则。 可我没能找出这样的例子。 但我找到了另外一个例子：当没有指定任何额外信息的时候，make会从 foo.c 一步编译出 foo， 而当给定规则<code>foo: foo.o</code> 的时候，因为显式提到了 foo.o, make 会先编译出 foo.o 再链接 生成 foo。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">ls</span>
bar.c  foo.c  mk1
<span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">cat</span> mk1
foo: foo.o
        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $<span class="token operator">&lt;</span>
<span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">make</span> foo
cc     foo.c   -o foo
<span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">make</span> bar
cc     bar.c   -o bar
<span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">rm</span> foo bar
<span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">make</span> -f mk1 foo
cc    -c -o foo.o foo.c
cc -o foo foo.o
<span class="token punctuation">[</span>chenx@lcs2 test1<span class="token punctuation">]</span>$ <span class="token function">make</span> -f mk1 bar
cc     bar.c   -o bar
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如果多个模式规则都匹配（且对应的依赖都实际存在），那么主干最短的那条规则优先，如果一样长，那么在makefile中的位置 靠前的规则优先。 It is possible that more than one pattern rule will meet these criteria. In that case, make will choose the rule with the shortest stem (that is, the pattern that matches most specifically). If more than one pattern rule has the shortest stem, make will choose the first one found in the makefile.</p><p>This algorithm results in more specific rules being preferred over more generic ones; for example:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>%.o: %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) <!--vuepress-ssr-app-->lt; -o $@

%.o : %.f
        $(COMPILE.F) $(OUTPUT_OPTION) <!--vuepress-ssr-app-->lt;

lib/%.o: lib/%.c
        $(CC) -fPIC -c $(CFLAGS) $(CPPFLAGS) <!--vuepress-ssr-app-->lt; -o $@
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Given these rules and asked to build bar.o where both bar.c and bar.f exist, make will choose the first rule and compile bar.c into bar.o. In the same situation where bar.c does not exist, then make will choose the second rule and compile bar.f into bar.o.</p><p>If make is asked to build lib/bar.o and both lib/bar.c and lib/bar.f exist, then the third rule will be chosen since the stem for this rule (‘bar’) is shorter than the stem for the first rule (‘lib/bar’). If lib/bar.c does not exist then the third rule is not eligible and the second rule will be used, even though the stem is longer.</p><h3 id="_10-5-5-match-anything-pattern-rules" tabindex="-1"><a class="header-anchor" href="#_10-5-5-match-anything-pattern-rules" aria-hidden="true">#</a> 10.5.5 Match-Anything Pattern Rules</h3><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/xizhan1995/xizhan1995.github.io/edit/main/make/note-make-手册.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: chenxizhan1995@163.com">chenxizhan</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.11a37516.js" defer></script>
  </body>
</html>
